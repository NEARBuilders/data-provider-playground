{"version":3,"file":"vendors-node_modules_bun_orpc_client_1_10_4_node_modules_orpc_client_dist_shared_client_DmkMd-ec2cea.js","sources":["webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/shared/client.DmkMd_GB.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/async.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/object.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs"],"sourcesContent":["import { resolveMaybeOptionalOptions, getConstructor, isObject, AsyncIteratorClass, isTypescriptObject } from '@orpc/shared';\nimport { getEventMeta, withEventMeta } from '@orpc/standard-server';\n\nconst ORPC_CLIENT_PACKAGE_NAME = \"@orpc/client\";\nconst ORPC_CLIENT_PACKAGE_VERSION = \"1.10.4\";\n\nconst COMMON_ORPC_ERROR_DEFS = {\n  BAD_REQUEST: {\n    status: 400,\n    message: \"Bad Request\"\n  },\n  UNAUTHORIZED: {\n    status: 401,\n    message: \"Unauthorized\"\n  },\n  FORBIDDEN: {\n    status: 403,\n    message: \"Forbidden\"\n  },\n  NOT_FOUND: {\n    status: 404,\n    message: \"Not Found\"\n  },\n  METHOD_NOT_SUPPORTED: {\n    status: 405,\n    message: \"Method Not Supported\"\n  },\n  NOT_ACCEPTABLE: {\n    status: 406,\n    message: \"Not Acceptable\"\n  },\n  TIMEOUT: {\n    status: 408,\n    message: \"Request Timeout\"\n  },\n  CONFLICT: {\n    status: 409,\n    message: \"Conflict\"\n  },\n  PRECONDITION_FAILED: {\n    status: 412,\n    message: \"Precondition Failed\"\n  },\n  PAYLOAD_TOO_LARGE: {\n    status: 413,\n    message: \"Payload Too Large\"\n  },\n  UNSUPPORTED_MEDIA_TYPE: {\n    status: 415,\n    message: \"Unsupported Media Type\"\n  },\n  UNPROCESSABLE_CONTENT: {\n    status: 422,\n    message: \"Unprocessable Content\"\n  },\n  TOO_MANY_REQUESTS: {\n    status: 429,\n    message: \"Too Many Requests\"\n  },\n  CLIENT_CLOSED_REQUEST: {\n    status: 499,\n    message: \"Client Closed Request\"\n  },\n  INTERNAL_SERVER_ERROR: {\n    status: 500,\n    message: \"Internal Server Error\"\n  },\n  NOT_IMPLEMENTED: {\n    status: 501,\n    message: \"Not Implemented\"\n  },\n  BAD_GATEWAY: {\n    status: 502,\n    message: \"Bad Gateway\"\n  },\n  SERVICE_UNAVAILABLE: {\n    status: 503,\n    message: \"Service Unavailable\"\n  },\n  GATEWAY_TIMEOUT: {\n    status: 504,\n    message: \"Gateway Timeout\"\n  }\n};\nfunction fallbackORPCErrorStatus(code, status) {\n  return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;\n}\nfunction fallbackORPCErrorMessage(code, message) {\n  return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;\n}\nconst GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(`__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`);\nvoid (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());\nconst globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];\nclass ORPCError extends Error {\n  defined;\n  code;\n  status;\n  data;\n  constructor(code, ...rest) {\n    const options = resolveMaybeOptionalOptions(rest);\n    if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {\n      throw new Error(\"[ORPCError] Invalid error status code.\");\n    }\n    const message = fallbackORPCErrorMessage(code, options.message);\n    super(message, options);\n    this.code = code;\n    this.status = fallbackORPCErrorStatus(code, options.status);\n    this.defined = options.defined ?? false;\n    this.data = options.data;\n  }\n  toJSON() {\n    return {\n      defined: this.defined,\n      code: this.code,\n      status: this.status,\n      message: this.message,\n      data: this.data\n    };\n  }\n  /**\n   * Workaround for Next.js where different contexts use separate\n   * dependency graphs, causing multiple ORPCError constructors existing and breaking\n   * `instanceof` checks across contexts.\n   *\n   * This is particularly problematic with \"Optimized SSR\", where orpc-client\n   * executes in one context but is invoked from another. When an error is thrown\n   * in the execution context, `instanceof ORPCError` checks fail in the\n   * invocation context due to separate class constructors.\n   *\n   * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.\n   */\n  static [Symbol.hasInstance](instance) {\n    if (globalORPCErrorConstructors.has(this)) {\n      const constructor = getConstructor(instance);\n      if (constructor && globalORPCErrorConstructors.has(constructor)) {\n        return true;\n      }\n    }\n    return super[Symbol.hasInstance](instance);\n  }\n}\nglobalORPCErrorConstructors.add(ORPCError);\nfunction isDefinedError(error) {\n  return error instanceof ORPCError && error.defined;\n}\nfunction toORPCError(error) {\n  return error instanceof ORPCError ? error : new ORPCError(\"INTERNAL_SERVER_ERROR\", {\n    message: \"Internal server error\",\n    cause: error\n  });\n}\nfunction isORPCErrorStatus(status) {\n  return status < 200 || status >= 400;\n}\nfunction isORPCErrorJson(json) {\n  if (!isObject(json)) {\n    return false;\n  }\n  const validKeys = [\"defined\", \"code\", \"status\", \"message\", \"data\"];\n  if (Object.keys(json).some((k) => !validKeys.includes(k))) {\n    return false;\n  }\n  return \"defined\" in json && typeof json.defined === \"boolean\" && \"code\" in json && typeof json.code === \"string\" && \"status\" in json && typeof json.status === \"number\" && isORPCErrorStatus(json.status) && \"message\" in json && typeof json.message === \"string\";\n}\nfunction createORPCErrorFromJson(json, options = {}) {\n  return new ORPCError(json.code, {\n    ...options,\n    ...json\n  });\n}\n\nfunction mapEventIterator(iterator, maps) {\n  const mapError = async (error) => {\n    let mappedError = await maps.error(error);\n    if (mappedError !== error) {\n      const meta = getEventMeta(error);\n      if (meta && isTypescriptObject(mappedError)) {\n        mappedError = withEventMeta(mappedError, meta);\n      }\n    }\n    return mappedError;\n  };\n  return new AsyncIteratorClass(async () => {\n    const { done, value } = await (async () => {\n      try {\n        return await iterator.next();\n      } catch (error) {\n        throw await mapError(error);\n      }\n    })();\n    let mappedValue = await maps.value(value, done);\n    if (mappedValue !== value) {\n      const meta = getEventMeta(value);\n      if (meta && isTypescriptObject(mappedValue)) {\n        mappedValue = withEventMeta(mappedValue, meta);\n      }\n    }\n    return { done, value: mappedValue };\n  }, async () => {\n    try {\n      await iterator.return?.();\n    } catch (error) {\n      throw await mapError(error);\n    }\n  });\n}\n\nexport { COMMON_ORPC_ERROR_DEFS as C, ORPC_CLIENT_PACKAGE_NAME as O, ORPC_CLIENT_PACKAGE_VERSION as a, fallbackORPCErrorMessage as b, ORPCError as c, isORPCErrorStatus as d, isORPCErrorJson as e, fallbackORPCErrorStatus as f, createORPCErrorFromJson as g, isDefinedError as i, mapEventIterator as m, toORPCError as t };\n","export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';\n\nfunction resolveMaybeOptionalOptions(rest) {\n  return rest[0] ?? {};\n}\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];\n}\nfunction splitInHalf(arr) {\n  const half = Math.ceil(arr.length / 2);\n  return [arr.slice(0, half), arr.slice(half)];\n}\n\nfunction readAsBuffer(source) {\n  if (typeof source.bytes === \"function\") {\n    return source.bytes();\n  }\n  return source.arrayBuffer();\n}\n\nconst ORPC_NAME = \"orpc\";\nconst ORPC_SHARED_PACKAGE_NAME = \"@orpc/shared\";\nconst ORPC_SHARED_PACKAGE_VERSION = \"1.10.4\";\n\nclass AbortError extends Error {\n  constructor(...rest) {\n    super(...rest);\n    this.name = \"AbortError\";\n  }\n}\n\nfunction once(fn) {\n  let cached;\n  return () => {\n    if (cached) {\n      return cached.result;\n    }\n    const result = fn();\n    cached = { result };\n    return result;\n  };\n}\nfunction sequential(fn) {\n  let lastOperationPromise = Promise.resolve();\n  return (...args) => {\n    return lastOperationPromise = lastOperationPromise.catch(() => {\n    }).then(() => {\n      return fn(...args);\n    });\n  };\n}\nfunction defer(callback) {\n  if (typeof setTimeout === \"function\") {\n    setTimeout(callback, 0);\n  } else {\n    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));\n  }\n}\n\nconst SPAN_ERROR_STATUS = 2;\nconst GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;\nfunction setGlobalOtelConfig(config) {\n  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;\n}\nfunction getGlobalOtelConfig() {\n  return globalThis[GLOBAL_OTEL_CONFIG_KEY];\n}\nfunction startSpan(name, options = {}, context) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  return tracer?.startSpan(name, options, context);\n}\nfunction setSpanError(span, error, options = {}) {\n  if (!span) {\n    return;\n  }\n  const exception = toOtelException(error);\n  span.recordException(exception);\n  if (!options.signal?.aborted || options.signal.reason !== error) {\n    span.setStatus({\n      code: SPAN_ERROR_STATUS,\n      message: exception.message\n    });\n  }\n}\nfunction setSpanAttribute(span, key, value) {\n  if (!span || value === void 0) {\n    return;\n  }\n  span.setAttribute(key, value);\n}\nfunction toOtelException(error) {\n  if (error instanceof Error) {\n    const exception = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    if (\"code\" in error && (typeof error.code === \"string\" || typeof error.code === \"number\")) {\n      exception.code = error.code;\n    }\n    return exception;\n  }\n  return { message: String(error) };\n}\nfunction toSpanAttributeValue(data) {\n  if (data === void 0) {\n    return \"undefined\";\n  }\n  try {\n    return JSON.stringify(data, (_, value) => {\n      if (typeof value === \"bigint\") {\n        return value.toString();\n      }\n      if (value instanceof Map || value instanceof Set) {\n        return Array.from(value);\n      }\n      return value;\n    });\n  } catch {\n    return String(data);\n  }\n}\nasync function runWithSpan({ name, context, ...options }, fn) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  if (!tracer) {\n    return fn();\n  }\n  const callback = async (span) => {\n    try {\n      return await fn(span);\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span.end();\n    }\n  };\n  if (context) {\n    return tracer.startActiveSpan(name, options, context, callback);\n  } else {\n    return tracer.startActiveSpan(name, options, callback);\n  }\n}\nasync function runInSpanContext(span, fn) {\n  const otelConfig = getGlobalOtelConfig();\n  if (!span || !otelConfig) {\n    return fn();\n  }\n  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);\n  return otelConfig.context.with(ctx, fn);\n}\n\nclass AsyncIdQueue {\n  openIds = /* @__PURE__ */ new Set();\n  queues = /* @__PURE__ */ new Map();\n  waiters = /* @__PURE__ */ new Map();\n  get length() {\n    return this.openIds.size;\n  }\n  get waiterIds() {\n    return Array.from(this.waiters.keys());\n  }\n  hasBufferedItems(id) {\n    return Boolean(this.queues.get(id)?.length);\n  }\n  open(id) {\n    this.openIds.add(id);\n  }\n  isOpen(id) {\n    return this.openIds.has(id);\n  }\n  push(id, item) {\n    this.assertOpen(id);\n    const pending = this.waiters.get(id);\n    if (pending?.length) {\n      pending.shift()[0](item);\n      if (pending.length === 0) {\n        this.waiters.delete(id);\n      }\n    } else {\n      const items = this.queues.get(id);\n      if (items) {\n        items.push(item);\n      } else {\n        this.queues.set(id, [item]);\n      }\n    }\n  }\n  async pull(id) {\n    this.assertOpen(id);\n    const items = this.queues.get(id);\n    if (items?.length) {\n      const item = items.shift();\n      if (items.length === 0) {\n        this.queues.delete(id);\n      }\n      return item;\n    }\n    return new Promise((resolve, reject) => {\n      const waitingPulls = this.waiters.get(id);\n      const pending = [resolve, reject];\n      if (waitingPulls) {\n        waitingPulls.push(pending);\n      } else {\n        this.waiters.set(id, [pending]);\n      }\n    });\n  }\n  close({ id, reason } = {}) {\n    if (id === void 0) {\n      this.waiters.forEach((pendingPulls, id2) => {\n        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);\n        pendingPulls.forEach(([, reject]) => reject(error2));\n      });\n      this.waiters.clear();\n      this.openIds.clear();\n      this.queues.clear();\n      return;\n    }\n    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);\n    this.waiters.get(id)?.forEach(([, reject]) => reject(error));\n    this.waiters.delete(id);\n    this.openIds.delete(id);\n    this.queues.delete(id);\n  }\n  assertOpen(id) {\n    if (!this.isOpen(id)) {\n      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);\n    }\n  }\n}\n\nfunction isAsyncIteratorObject(maybe) {\n  if (!maybe || typeof maybe !== \"object\") {\n    return false;\n  }\n  return \"next\" in maybe && typeof maybe.next === \"function\" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === \"function\";\n}\nconst fallbackAsyncDisposeSymbol = Symbol.for(\"asyncDispose\");\nconst asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;\nclass AsyncIteratorClass {\n  #isDone = false;\n  #isExecuteComplete = false;\n  #cleanup;\n  #next;\n  constructor(next, cleanup) {\n    this.#cleanup = cleanup;\n    this.#next = sequential(async () => {\n      if (this.#isDone) {\n        return { done: true, value: void 0 };\n      }\n      try {\n        const result = await next();\n        if (result.done) {\n          this.#isDone = true;\n        }\n        return result;\n      } catch (err) {\n        this.#isDone = true;\n        throw err;\n      } finally {\n        if (this.#isDone && !this.#isExecuteComplete) {\n          this.#isExecuteComplete = true;\n          await this.#cleanup(\"next\");\n        }\n      }\n    });\n  }\n  next() {\n    return this.#next();\n  }\n  async return(value) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"return\");\n    }\n    return { done: true, value };\n  }\n  async throw(err) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"throw\");\n    }\n    throw err;\n  }\n  /**\n   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')\n   */\n  async [asyncDisposeSymbol]() {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"dispose\");\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nfunction replicateAsyncIterator(source, count) {\n  const queue = new AsyncIdQueue();\n  const ids = Array.from({ length: count }, (_, i) => i.toString());\n  let isSourceFinished = false;\n  const start = once(async () => {\n    try {\n      while (true) {\n        const item = await source.next();\n        ids.forEach((id) => {\n          if (queue.isOpen(id)) {\n            queue.push(id, { next: item });\n          }\n        });\n        if (item.done) {\n          break;\n        }\n      }\n    } catch (error) {\n      ids.forEach((id) => {\n        if (queue.isOpen(id)) {\n          queue.push(id, { error });\n        }\n      });\n    } finally {\n      isSourceFinished = true;\n    }\n  });\n  const replicated = ids.map((id) => {\n    queue.open(id);\n    return new AsyncIteratorClass(\n      async () => {\n        start();\n        const item = await queue.pull(id);\n        if (item.next) {\n          return item.next;\n        }\n        throw item.error;\n      },\n      async (reason) => {\n        queue.close({ id });\n        if (reason !== \"next\" && !queue.length && !isSourceFinished) {\n          isSourceFinished = true;\n          await source?.return?.();\n        }\n      }\n    );\n  });\n  return replicated;\n}\nfunction asyncIteratorWithSpan({ name, ...options }, iterator) {\n  let span;\n  return new AsyncIteratorClass(\n    async () => {\n      span ??= startSpan(name);\n      try {\n        const result = await runInSpanContext(span, () => iterator.next());\n        span?.addEvent(result.done ? \"completed\" : \"yielded\");\n        return result;\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      }\n    },\n    async (reason) => {\n      try {\n        if (reason !== \"next\") {\n          await runInSpanContext(span, () => iterator.return?.());\n        }\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      } finally {\n        span?.end();\n      }\n    }\n  );\n}\n\nclass EventPublisher {\n  #listenersMap = /* @__PURE__ */ new Map();\n  #maxBufferedEvents;\n  constructor(options = {}) {\n    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;\n  }\n  get size() {\n    return this.#listenersMap.size;\n  }\n  /**\n   * Emits an event and delivers the payload to all subscribed listeners.\n   */\n  publish(event, payload) {\n    const listeners = this.#listenersMap.get(event);\n    if (!listeners) {\n      return;\n    }\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n  subscribe(event, listenerOrOptions) {\n    if (typeof listenerOrOptions === \"function\") {\n      let listeners = this.#listenersMap.get(event);\n      if (!listeners) {\n        this.#listenersMap.set(event, listeners = []);\n      }\n      listeners.push(listenerOrOptions);\n      return once(() => {\n        listeners.splice(listeners.indexOf(listenerOrOptions), 1);\n        if (listeners.length === 0) {\n          this.#listenersMap.delete(event);\n        }\n      });\n    }\n    const signal = listenerOrOptions?.signal;\n    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;\n    signal?.throwIfAborted();\n    const bufferedEvents = [];\n    const pullResolvers = [];\n    const unsubscribe = this.subscribe(event, (payload) => {\n      const resolver = pullResolvers.shift();\n      if (resolver) {\n        resolver[0]({ done: false, value: payload });\n      } else {\n        bufferedEvents.push(payload);\n        if (bufferedEvents.length > maxBufferedEvents) {\n          bufferedEvents.shift();\n        }\n      }\n    });\n    const abortListener = (event2) => {\n      unsubscribe();\n      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    };\n    signal?.addEventListener(\"abort\", abortListener, { once: true });\n    return new AsyncIteratorClass(async () => {\n      if (signal?.aborted) {\n        throw signal.reason;\n      }\n      if (bufferedEvents.length > 0) {\n        return { done: false, value: bufferedEvents.shift() };\n      }\n      return new Promise((resolve, reject) => {\n        pullResolvers.push([resolve, reject]);\n      });\n    }, async () => {\n      unsubscribe();\n      signal?.removeEventListener(\"abort\", abortListener);\n      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    });\n  }\n}\n\nclass SequentialIdGenerator {\n  index = BigInt(1);\n  generate() {\n    const id = this.index.toString(36);\n    this.index++;\n    return id;\n  }\n}\nfunction compareSequentialIds(a, b) {\n  if (a.length !== b.length) {\n    return a.length - b.length;\n  }\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction onStart(callback) {\n  return async (options, ...rest) => {\n    await callback(options, ...rest);\n    return await options.next();\n  };\n}\nfunction onSuccess(callback) {\n  return async (options, ...rest) => {\n    const result = await options.next();\n    await callback(result, options, ...rest);\n    return result;\n  };\n}\nfunction onError(callback) {\n  return async (options, ...rest) => {\n    try {\n      return await options.next();\n    } catch (error) {\n      await callback(error, options, ...rest);\n      throw error;\n    }\n  };\n}\nfunction onFinish(callback) {\n  let state;\n  return async (options, ...rest) => {\n    try {\n      const result = await options.next();\n      state = [null, result, true];\n      return result;\n    } catch (error) {\n      state = [error, void 0, false];\n      throw error;\n    } finally {\n      await callback(state, options, ...rest);\n    }\n  };\n}\nfunction intercept(interceptors, options, main) {\n  const next = (options2, index) => {\n    const interceptor = interceptors[index];\n    if (!interceptor) {\n      return main(options2);\n    }\n    return interceptor({\n      ...options2,\n      next: (newOptions = options2) => next(newOptions, index + 1)\n    });\n  };\n  return next(options, 0);\n}\n\nfunction parseEmptyableJSON(text) {\n  if (!text) {\n    return void 0;\n  }\n  return JSON.parse(text);\n}\nfunction stringifyJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction findDeepMatches(check, payload, segments = [], maps = [], values = []) {\n  if (check(payload)) {\n    maps.push(segments);\n    values.push(payload);\n  } else if (Array.isArray(payload)) {\n    payload.forEach((v, i) => {\n      findDeepMatches(check, v, [...segments, i], maps, values);\n    });\n  } else if (isObject(payload)) {\n    for (const key in payload) {\n      findDeepMatches(check, payload[key], [...segments, key], maps, values);\n    }\n  }\n  return { maps, values };\n}\nfunction getConstructor(value) {\n  if (!isTypescriptObject(value)) {\n    return null;\n  }\n  return Object.getPrototypeOf(value)?.constructor;\n}\nfunction isObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || !proto || !proto.constructor;\n}\nfunction isTypescriptObject(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  }\n  if (isObject(value)) {\n    const result = {};\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n    return result;\n  }\n  return value;\n}\nfunction get(object, path) {\n  let current = object;\n  for (const key of path) {\n    if (!isTypescriptObject(current)) {\n      return void 0;\n    }\n    current = current[key];\n  }\n  return current;\n}\nfunction isPropertyKey(value) {\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"symbol\";\n}\nconst NullProtoObj = /* @__PURE__ */ (() => {\n  const e = function() {\n  };\n  e.prototype = /* @__PURE__ */ Object.create(null);\n  Object.freeze(e.prototype);\n  return e;\n})();\n\nfunction value(value2, ...args) {\n  if (typeof value2 === \"function\") {\n    return value2(...args);\n  }\n  return value2;\n}\nfunction fallback(value2, fallback2) {\n  return value2 === void 0 ? fallback2 : value2;\n}\n\nfunction preventNativeAwait(target) {\n  return new Proxy(target, {\n    get(target2, prop, receiver) {\n      const value2 = Reflect.get(target2, prop, receiver);\n      if (prop !== \"then\" || typeof value2 !== \"function\") {\n        return value2;\n      }\n      return new Proxy(value2, {\n        apply(targetFn, thisArg, args) {\n          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {\n            return Reflect.apply(targetFn, thisArg, args);\n          }\n          let shouldOmit = true;\n          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {\n            get: (target3, prop2, receiver2) => {\n              if (shouldOmit && prop2 === \"then\") {\n                shouldOmit = false;\n                return void 0;\n              }\n              return Reflect.get(target3, prop2, receiver2);\n            }\n          })));\n        }\n      });\n    }\n  });\n}\nconst NATIVE_FUNCTION_REGEX = /^\\s*function\\s*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/;\nfunction isNativeFunction(fn) {\n  return typeof fn === \"function\" && NATIVE_FUNCTION_REGEX.test(fn.toString());\n}\nfunction overlayProxy(target, partial) {\n  const proxy = new Proxy(typeof target === \"function\" ? partial : target, {\n    get(_, prop) {\n      const targetValue = prop in partial ? partial : value(target);\n      const v = Reflect.get(targetValue, prop);\n      return typeof v === \"function\" ? v.bind(targetValue) : v;\n    },\n    has(_, prop) {\n      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);\n    }\n  });\n  return proxy;\n}\n\nfunction streamToAsyncIteratorClass(stream) {\n  const reader = stream.getReader();\n  return new AsyncIteratorClass(\n    async () => {\n      return reader.read();\n    },\n    async () => {\n      await reader.cancel();\n    }\n  );\n}\nfunction asyncIteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\nfunction asyncIteratorToUnproxiedDataStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;\n        controller.enqueue(unproxied);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\n\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n}\n\nexport { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };\n","import { isTypescriptObject, AsyncIteratorClass, tryDecodeURIComponent, toArray, once, isAsyncIteratorObject, replicateAsyncIterator } from '@orpc/shared';\n\nclass EventEncoderError extends TypeError {\n}\nclass EventDecoderError extends TypeError {\n}\nclass ErrorEvent extends Error {\n  data;\n  constructor(options) {\n    super(options?.message ?? \"An error event was received\", options);\n    this.data = options?.data;\n  }\n}\n\nfunction decodeEventMessage(encoded) {\n  const lines = encoded.replace(/\\n+$/, \"\").split(/\\n/);\n  const message = {\n    data: void 0,\n    event: void 0,\n    id: void 0,\n    retry: void 0,\n    comments: []\n  };\n  for (const line of lines) {\n    const index = line.indexOf(\":\");\n    const key = index === -1 ? line : line.slice(0, index);\n    const value = index === -1 ? \"\" : line.slice(index + 1).replace(/^\\s/, \"\");\n    if (index === 0) {\n      message.comments.push(value);\n    } else if (key === \"data\") {\n      message.data ??= \"\";\n      message.data += `${value}\n`;\n    } else if (key === \"event\") {\n      message.event = value;\n    } else if (key === \"id\") {\n      message.id = value;\n    } else if (key === \"retry\") {\n      const maybeInteger = Number.parseInt(value);\n      if (Number.isInteger(maybeInteger) && maybeInteger >= 0 && maybeInteger.toString() === value) {\n        message.retry = maybeInteger;\n      }\n    }\n  }\n  message.data = message.data?.replace(/\\n$/, \"\");\n  return message;\n}\nclass EventDecoder {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  incomplete = \"\";\n  feed(chunk) {\n    this.incomplete += chunk;\n    const lastCompleteIndex = this.incomplete.lastIndexOf(\"\\n\\n\");\n    if (lastCompleteIndex === -1) {\n      return;\n    }\n    const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\\n\\n/);\n    this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);\n    for (const encoded of completes) {\n      const message = decodeEventMessage(`${encoded}\n\n`);\n      if (this.options.onEvent) {\n        this.options.onEvent(message);\n      }\n    }\n    this.incomplete = \"\";\n  }\n  end() {\n    if (this.incomplete) {\n      throw new EventDecoderError(\"Event Iterator ended before complete\");\n    }\n  }\n}\nclass EventDecoderStream extends TransformStream {\n  constructor() {\n    let decoder;\n    super({\n      start(controller) {\n        decoder = new EventDecoder({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          }\n        });\n      },\n      transform(chunk) {\n        decoder.feed(chunk);\n      },\n      flush() {\n        decoder.end();\n      }\n    });\n  }\n}\n\nfunction assertEventId(id) {\n  if (id.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's id must not contain a newline character\");\n  }\n}\nfunction assertEventName(event) {\n  if (event.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's event must not contain a newline character\");\n  }\n}\nfunction assertEventRetry(retry) {\n  if (!Number.isInteger(retry) || retry < 0) {\n    throw new EventEncoderError(\"Event's retry must be a integer and >= 0\");\n  }\n}\nfunction assertEventComment(comment) {\n  if (comment.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's comment must not contain a newline character\");\n  }\n}\nfunction encodeEventData(data) {\n  const lines = data?.split(/\\n/) ?? [];\n  let output = \"\";\n  for (const line of lines) {\n    output += `data: ${line}\n`;\n  }\n  return output;\n}\nfunction encodeEventComments(comments) {\n  let output = \"\";\n  for (const comment of comments ?? []) {\n    assertEventComment(comment);\n    output += `: ${comment}\n`;\n  }\n  return output;\n}\nfunction encodeEventMessage(message) {\n  let output = \"\";\n  output += encodeEventComments(message.comments);\n  if (message.event !== void 0) {\n    assertEventName(message.event);\n    output += `event: ${message.event}\n`;\n  }\n  if (message.retry !== void 0) {\n    assertEventRetry(message.retry);\n    output += `retry: ${message.retry}\n`;\n  }\n  if (message.id !== void 0) {\n    assertEventId(message.id);\n    output += `id: ${message.id}\n`;\n  }\n  output += encodeEventData(message.data);\n  output += \"\\n\";\n  return output;\n}\n\nconst EVENT_SOURCE_META_SYMBOL = Symbol(\"ORPC_EVENT_SOURCE_META\");\nfunction withEventMeta(container, meta) {\n  if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {\n    return container;\n  }\n  if (meta.id !== void 0) {\n    assertEventId(meta.id);\n  }\n  if (meta.retry !== void 0) {\n    assertEventRetry(meta.retry);\n  }\n  if (meta.comments !== void 0) {\n    for (const comment of meta.comments) {\n      assertEventComment(comment);\n    }\n  }\n  return new Proxy(container, {\n    get(target, prop, receiver) {\n      if (prop === EVENT_SOURCE_META_SYMBOL) {\n        return meta;\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction getEventMeta(container) {\n  return isTypescriptObject(container) ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL) : void 0;\n}\n\nclass HibernationEventIterator extends AsyncIteratorClass {\n  /**\n   * this property is not transferred to the client, so it should be optional for type safety\n   */\n  hibernationCallback;\n  constructor(hibernationCallback) {\n    super(async () => {\n      throw new Error(\"Cannot iterate over hibernating iterator directly\");\n    }, async (reason) => {\n      if (reason !== \"next\") {\n        throw new Error(\"Cannot cleanup hibernating iterator directly\");\n      }\n    });\n    this.hibernationCallback = hibernationCallback;\n  }\n}\n\nfunction generateContentDisposition(filename) {\n  const escapedFileName = filename.replace(/\"/g, '\\\\\"');\n  const encodedFilenameStar = encodeURIComponent(filename).replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));\n  return `inline; filename=\"${escapedFileName}\"; filename*=utf-8''${encodedFilenameStar}`;\n}\nfunction getFilenameFromContentDisposition(contentDisposition) {\n  const encodedFilenameStarMatch = contentDisposition.match(/filename\\*=(UTF-8'')?([^;]*)/i);\n  if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === \"string\") {\n    return tryDecodeURIComponent(encodedFilenameStarMatch[2]);\n  }\n  const encodedFilenameMatch = contentDisposition.match(/filename=\"((?:\\\\\"|[^\"])*)\"/i);\n  if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === \"string\") {\n    return encodedFilenameMatch[1].replace(/\\\\\"/g, '\"');\n  }\n}\nfunction mergeStandardHeaders(a, b) {\n  const merged = { ...a };\n  for (const key in b) {\n    if (Array.isArray(b[key])) {\n      merged[key] = [...toArray(merged[key]), ...b[key]];\n    } else if (b[key] !== void 0) {\n      if (Array.isArray(merged[key])) {\n        merged[key] = [...merged[key], b[key]];\n      } else if (merged[key] !== void 0) {\n        merged[key] = [merged[key], b[key]];\n      } else {\n        merged[key] = b[key];\n      }\n    }\n  }\n  return merged;\n}\nfunction flattenHeader(header) {\n  if (typeof header === \"string\" || header === void 0) {\n    return header;\n  }\n  if (header.length === 0) {\n    return void 0;\n  }\n  return header.join(\", \");\n}\nfunction replicateStandardLazyResponse(response, count) {\n  const replicated = [];\n  let bodyPromise;\n  let replicatedAsyncIteratorObjects;\n  for (let i = 0; i < count; i++) {\n    replicated.push({\n      ...response,\n      body: once(async () => {\n        const body = await (bodyPromise ??= response.body());\n        if (!isAsyncIteratorObject(body)) {\n          return body;\n        }\n        replicatedAsyncIteratorObjects ??= replicateAsyncIterator(body, count);\n        return replicatedAsyncIteratorObjects.shift();\n      })\n    });\n  }\n  return replicated;\n}\nfunction isEventIteratorHeaders(headers) {\n  return Boolean(flattenHeader(headers[\"content-type\"])?.startsWith(\"text/event-stream\") && flattenHeader(headers[\"content-disposition\"]) === void 0);\n}\n\nexport { ErrorEvent, EventDecoder, EventDecoderError, EventDecoderStream, EventEncoderError, HibernationEventIterator, assertEventComment, assertEventId, assertEventName, assertEventRetry, decodeEventMessage, encodeEventComments, encodeEventData, encodeEventMessage, flattenHeader, generateContentDisposition, getEventMeta, getFilenameFromContentDisposition, isEventIteratorHeaders, mergeStandardHeaders, replicateStandardLazyResponse, withEventMeta };\n","import { isFunction, isArray } from './typed.mjs';\n\nconst group = (array, getGroupId) => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item);\n    if (!acc[groupId])\n      acc[groupId] = [];\n    acc[groupId].push(item);\n    return acc;\n  }, {});\n};\nfunction zip(...arrays) {\n  if (!arrays || !arrays.length)\n    return [];\n  return new Array(Math.max(...arrays.map(({ length }) => length))).fill([]).map((_, idx) => arrays.map((array) => array[idx]));\n}\nfunction zipToObject(keys, values) {\n  if (!keys || !keys.length) {\n    return {};\n  }\n  const getValue = isFunction(values) ? values : isArray(values) ? (_k, i) => values[i] : (_k, _i) => values;\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx);\n    return acc;\n  }, {});\n}\nconst boil = (array, compareFunc) => {\n  if (!array || (array.length ?? 0) === 0)\n    return null;\n  return array.reduce(compareFunc);\n};\nfunction sum(array, fn) {\n  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0);\n}\nconst first = (array, defaultValue = void 0) => {\n  return array?.length > 0 ? array[0] : defaultValue;\n};\nconst last = (array, defaultValue = void 0) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue;\n};\nconst sort = (array, getter, desc = false) => {\n  if (!array)\n    return [];\n  const asc = (a, b) => getter(a) - getter(b);\n  const dsc = (a, b) => getter(b) - getter(a);\n  return array.slice().sort(desc === true ? dsc : asc);\n};\nconst alphabetical = (array, getter, dir = \"asc\") => {\n  if (!array)\n    return [];\n  const asc = (a, b) => `${getter(a)}`.localeCompare(getter(b));\n  const dsc = (a, b) => `${getter(b)}`.localeCompare(getter(a));\n  return array.slice().sort(dir === \"desc\" ? dsc : asc);\n};\nconst counting = (list2, identity) => {\n  if (!list2)\n    return {};\n  return list2.reduce((acc, item) => {\n    const id = identity(item);\n    acc[id] = (acc[id] ?? 0) + 1;\n    return acc;\n  }, {});\n};\nconst replace = (list2, newItem, match) => {\n  if (!list2)\n    return [];\n  if (newItem === void 0)\n    return [...list2];\n  for (let idx = 0; idx < list2.length; idx++) {\n    const item = list2[idx];\n    if (match(item, idx)) {\n      return [\n        ...list2.slice(0, idx),\n        newItem,\n        ...list2.slice(idx + 1, list2.length)\n      ];\n    }\n  }\n  return [...list2];\n};\nconst objectify = (array, getKey, getValue = (item) => item) => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item);\n    return acc;\n  }, {});\n};\nconst select = (array, mapper, condition) => {\n  if (!array)\n    return [];\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index))\n      return acc;\n    acc.push(mapper(item, index));\n    return acc;\n  }, []);\n};\nfunction max(array, getter) {\n  const get = getter ?? ((v) => v);\n  return boil(array, (a, b) => get(a) > get(b) ? a : b);\n}\nfunction min(array, getter) {\n  const get = getter ?? ((v) => v);\n  return boil(array, (a, b) => get(a) < get(b) ? a : b);\n}\nconst cluster = (list2, size = 2) => {\n  const clusterCount = Math.ceil(list2.length / size);\n  return new Array(clusterCount).fill(null).map((_c, i) => {\n    return list2.slice(i * size, i * size + size);\n  });\n};\nconst unique = (array, toKey) => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : item;\n    if (acc[key])\n      return acc;\n    acc[key] = item;\n    return acc;\n  }, {});\n  return Object.values(valueMap);\n};\nfunction* range(startOrLength, end, valueOrMapper = (i) => i, step = 1) {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper;\n  const start = end ? startOrLength : 0;\n  const final = end ?? startOrLength;\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i);\n    if (i + step > final)\n      break;\n  }\n}\nconst list = (startOrLength, end, valueOrMapper, step) => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step));\n};\nconst flat = (lists) => {\n  return lists.reduce((acc, list2) => {\n    acc.push(...list2);\n    return acc;\n  }, []);\n};\nconst intersects = (listA, listB, identity) => {\n  if (!listA || !listB)\n    return false;\n  const ident = identity ?? ((x) => x);\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true;\n    return acc;\n  }, {});\n  return listA.some((value) => dictB[ident(value)]);\n};\nconst fork = (list2, condition) => {\n  if (!list2)\n    return [[], []];\n  return list2.reduce(\n    (acc, item) => {\n      const [a, b] = acc;\n      if (condition(item)) {\n        return [[...a, item], b];\n      } else {\n        return [a, [...b, item]];\n      }\n    },\n    [[], []]\n  );\n};\nconst merge = (root, others, matcher) => {\n  if (!others && !root)\n    return [];\n  if (!others)\n    return root;\n  if (!root)\n    return [];\n  if (!matcher)\n    return root;\n  return root.reduce((acc, r) => {\n    const matched = others.find((o) => matcher(r) === matcher(o));\n    if (matched)\n      acc.push(matched);\n    else\n      acc.push(r);\n    return acc;\n  }, []);\n};\nconst replaceOrAppend = (list2, newItem, match) => {\n  if (!list2 && !newItem)\n    return [];\n  if (!newItem)\n    return [...list2];\n  if (!list2)\n    return [newItem];\n  for (let idx = 0; idx < list2.length; idx++) {\n    const item = list2[idx];\n    if (match(item, idx)) {\n      return [\n        ...list2.slice(0, idx),\n        newItem,\n        ...list2.slice(idx + 1, list2.length)\n      ];\n    }\n  }\n  return [...list2, newItem];\n};\nconst toggle = (list2, item, toKey, options) => {\n  if (!list2 && !item)\n    return [];\n  if (!list2)\n    return [item];\n  if (!item)\n    return [...list2];\n  const matcher = toKey ? (x, idx) => toKey(x, idx) === toKey(item, idx) : (x) => x === item;\n  const existing = list2.find(matcher);\n  if (existing)\n    return list2.filter((x, idx) => !matcher(x, idx));\n  const strategy = options?.strategy ?? \"append\";\n  if (strategy === \"append\")\n    return [...list2, item];\n  return [item, ...list2];\n};\nconst sift = (list2) => {\n  return list2?.filter((x) => !!x) ?? [];\n};\nconst iterate = (count, func, initValue) => {\n  let value = initValue;\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i);\n  }\n  return value;\n};\nconst diff = (root, other, identity = (t) => t) => {\n  if (!root?.length && !other?.length)\n    return [];\n  if (root?.length === void 0)\n    return [...other];\n  if (!other?.length)\n    return [...root];\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true;\n    return acc;\n  }, {});\n  return root.filter((a) => !bKeys[identity(a)]);\n};\nfunction shift(arr, n) {\n  if (arr.length === 0)\n    return arr;\n  const shiftNumber = n % arr.length;\n  if (shiftNumber === 0)\n    return arr;\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)];\n}\n\nexport { alphabetical, boil, cluster, counting, diff, first, flat, fork, group, intersects, iterate, last, list, max, merge, min, objectify, range, replace, replaceOrAppend, select, shift, sift, sort, sum, toggle, unique, zip, zipToObject };\n//# sourceMappingURL=array.mjs.map\n","import { list, fork, sort, range } from './array.mjs';\nimport { isArray, isPromise } from './typed.mjs';\n\nconst reduce = async (array, asyncReducer, initValue) => {\n  const initProvided = initValue !== void 0;\n  if (!initProvided && array?.length < 1) {\n    throw new Error(\"Cannot reduce empty array with no init value\");\n  }\n  const iter = initProvided ? array : array.slice(1);\n  let value = initProvided ? initValue : array[0];\n  for (const [i, item] of iter.entries()) {\n    value = await asyncReducer(value, item, i);\n  }\n  return value;\n};\nconst map = async (array, asyncMapFunc) => {\n  if (!array)\n    return [];\n  let result = [];\n  let index = 0;\n  for (const value of array) {\n    const newValue = await asyncMapFunc(value, index++);\n    result.push(newValue);\n  }\n  return result;\n};\nconst defer = async (func) => {\n  const callbacks = [];\n  const register = (fn, options) => callbacks.push({\n    fn,\n    rethrow: options?.rethrow ?? false\n  });\n  const [err, response] = await tryit(func)(register);\n  for (const { fn, rethrow } of callbacks) {\n    const [rethrown] = await tryit(fn)(err);\n    if (rethrown && rethrow)\n      throw rethrown;\n  }\n  if (err)\n    throw err;\n  return response;\n};\nclass AggregateError extends Error {\n  constructor(errors = []) {\n    super();\n    const name = errors.find((e) => e.name)?.name ?? \"\";\n    this.name = `AggregateError(${name}...)`;\n    this.message = `AggregateError with ${errors.length} errors`;\n    this.stack = errors.find((e) => e.stack)?.stack ?? this.stack;\n    this.errors = errors;\n  }\n}\nconst parallel = async (limit, array, func) => {\n  const work = array.map((item, index) => ({\n    index,\n    item\n  }));\n  const processor = async (res) => {\n    const results2 = [];\n    while (true) {\n      const next = work.pop();\n      if (!next)\n        return res(results2);\n      const [error, result] = await tryit(func)(next.item);\n      results2.push({\n        error,\n        result,\n        index: next.index\n      });\n    }\n  };\n  const queues = list(1, limit).map(() => new Promise(processor));\n  const itemResults = await Promise.all(queues);\n  const [errors, results] = fork(\n    sort(itemResults.flat(), (r) => r.index),\n    (x) => !!x.error\n  );\n  if (errors.length > 0) {\n    throw new AggregateError(errors.map((error) => error.error));\n  }\n  return results.map((r) => r.result);\n};\nasync function all(promises) {\n  const entries = isArray(promises) ? promises.map((p) => [null, p]) : Object.entries(promises);\n  const results = await Promise.all(\n    entries.map(\n      ([key, value]) => value.then((result) => ({ result, exc: null, key })).catch((exc) => ({ result: null, exc, key }))\n    )\n  );\n  const exceptions = results.filter((r) => r.exc);\n  if (exceptions.length > 0) {\n    throw new AggregateError(exceptions.map((e) => e.exc));\n  }\n  if (isArray(promises)) {\n    return results.map((r) => r.result);\n  }\n  return results.reduce(\n    (acc, item) => ({\n      ...acc,\n      [item.key]: item.result\n    }),\n    {}\n  );\n}\nconst retry = async (options, func) => {\n  const times = options?.times ?? 3;\n  const delay = options?.delay;\n  const backoff = options?.backoff ?? null;\n  for (const i of range(1, times)) {\n    const [err, result] = await tryit(func)((err2) => {\n      throw { _exited: err2 };\n    });\n    if (!err)\n      return result;\n    if (err._exited)\n      throw err._exited;\n    if (i === times)\n      throw err;\n    if (delay)\n      await sleep(delay);\n    if (backoff)\n      await sleep(backoff(i));\n  }\n  return void 0;\n};\nconst sleep = (milliseconds) => {\n  return new Promise((res) => setTimeout(res, milliseconds));\n};\nconst tryit = (func) => {\n  return (...args) => {\n    try {\n      const result = func(...args);\n      if (isPromise(result)) {\n        return result.then((value) => [void 0, value]).catch((err) => [err, void 0]);\n      }\n      return [void 0, result];\n    } catch (err) {\n      return [err, void 0];\n    }\n  };\n};\nconst guard = (func, shouldGuard) => {\n  const _guard = (err) => {\n    if (shouldGuard && !shouldGuard(err))\n      throw err;\n    return void 0;\n  };\n  const isPromise2 = (result) => result instanceof Promise;\n  try {\n    const result = func();\n    return isPromise2(result) ? result.catch(_guard) : result;\n  } catch (err) {\n    return _guard(err);\n  }\n};\n\nexport { AggregateError, all, defer, guard, map, parallel, reduce, retry, sleep, tryit };\n//# sourceMappingURL=async.mjs.map\n","import { objectify } from './array.mjs';\nimport { isPrimitive, isObject, isArray } from './typed.mjs';\n\nconst shake = (obj, filter = (x) => x === void 0) => {\n  if (!obj)\n    return {};\n  const keys2 = Object.keys(obj);\n  return keys2.reduce((acc, key) => {\n    if (filter(obj[key])) {\n      return acc;\n    } else {\n      acc[key] = obj[key];\n      return acc;\n    }\n  }, {});\n};\nconst mapKeys = (obj, mapFunc) => {\n  const keys2 = Object.keys(obj);\n  return keys2.reduce((acc, key) => {\n    acc[mapFunc(key, obj[key])] = obj[key];\n    return acc;\n  }, {});\n};\nconst mapValues = (obj, mapFunc) => {\n  const keys2 = Object.keys(obj);\n  return keys2.reduce((acc, key) => {\n    acc[key] = mapFunc(obj[key], key);\n    return acc;\n  }, {});\n};\nconst mapEntries = (obj, toEntry) => {\n  if (!obj)\n    return {};\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    const [newKey, newValue] = toEntry(key, value);\n    acc[newKey] = newValue;\n    return acc;\n  }, {});\n};\nconst invert = (obj) => {\n  if (!obj)\n    return {};\n  const keys2 = Object.keys(obj);\n  return keys2.reduce((acc, key) => {\n    acc[obj[key]] = key;\n    return acc;\n  }, {});\n};\nconst lowerize = (obj) => mapKeys(obj, (k) => k.toLowerCase());\nconst upperize = (obj) => mapKeys(obj, (k) => k.toUpperCase());\nconst clone = (obj) => {\n  if (isPrimitive(obj)) {\n    return obj;\n  }\n  if (typeof obj === \"function\") {\n    return obj.bind({});\n  }\n  const newObj = new obj.constructor();\n  Object.getOwnPropertyNames(obj).forEach((prop) => {\n    newObj[prop] = obj[prop];\n  });\n  return newObj;\n};\nconst listify = (obj, toItem) => {\n  if (!obj)\n    return [];\n  const entries = Object.entries(obj);\n  if (entries.length === 0)\n    return [];\n  return entries.reduce((acc, entry) => {\n    acc.push(toItem(entry[0], entry[1]));\n    return acc;\n  }, []);\n};\nconst pick = (obj, keys2) => {\n  if (!obj)\n    return {};\n  return keys2.reduce((acc, key) => {\n    if (Object.prototype.hasOwnProperty.call(obj, key))\n      acc[key] = obj[key];\n    return acc;\n  }, {});\n};\nconst omit = (obj, keys2) => {\n  if (!obj)\n    return {};\n  if (!keys2 || keys2.length === 0)\n    return obj;\n  return keys2.reduce(\n    (acc, key) => {\n      delete acc[key];\n      return acc;\n    },\n    { ...obj }\n  );\n};\nconst get = (value, path, defaultValue) => {\n  const segments = path.split(/[\\.\\[\\]]/g);\n  let current = value;\n  for (const key of segments) {\n    if (current === null)\n      return defaultValue;\n    if (current === void 0)\n      return defaultValue;\n    const dequoted = key.replace(/['\"]/g, \"\");\n    if (dequoted.trim() === \"\")\n      continue;\n    current = current[dequoted];\n  }\n  if (current === void 0)\n    return defaultValue;\n  return current;\n};\nconst set = (initial, path, value) => {\n  if (!initial)\n    return {};\n  if (!path || value === void 0)\n    return initial;\n  const segments = path.split(/[\\.\\[\\]]/g).filter((x) => !!x.trim());\n  const _set = (node) => {\n    if (segments.length > 1) {\n      const key = segments.shift();\n      const nextIsNum = /^\\d+$/.test(segments[0]);\n      node[key] = node[key] === void 0 ? nextIsNum ? [] : {} : node[key];\n      _set(node[key]);\n    } else {\n      node[segments[0]] = value;\n    }\n  };\n  const cloned = clone(initial);\n  _set(cloned);\n  return cloned;\n};\nconst assign = (initial, override) => {\n  if (!initial || !override)\n    return initial ?? override ?? {};\n  return Object.entries({ ...initial, ...override }).reduce(\n    (acc, [key, value]) => {\n      return {\n        ...acc,\n        [key]: (() => {\n          if (isObject(initial[key]))\n            return assign(initial[key], value);\n          return value;\n        })()\n      };\n    },\n    {}\n  );\n};\nconst keys = (value) => {\n  if (!value)\n    return [];\n  const getKeys = (nested, paths) => {\n    if (isObject(nested)) {\n      return Object.entries(nested).flatMap(\n        ([k, v]) => getKeys(v, [...paths, k])\n      );\n    }\n    if (isArray(nested)) {\n      return nested.flatMap((item, i) => getKeys(item, [...paths, `${i}`]));\n    }\n    return [paths.join(\".\")];\n  };\n  return getKeys(value, []);\n};\nconst crush = (value) => {\n  if (!value)\n    return {};\n  return objectify(\n    keys(value),\n    (k) => k,\n    (k) => get(value, k)\n  );\n};\nconst construct = (obj) => {\n  if (!obj)\n    return {};\n  return Object.keys(obj).reduce((acc, path) => {\n    return set(acc, path, obj[path]);\n  }, {});\n};\n\nexport { assign, clone, construct, crush, get, invert, keys, listify, lowerize, mapEntries, mapKeys, mapValues, omit, pick, set, shake, upperize };\n//# sourceMappingURL=object.mjs.map\n","const isSymbol = (value) => {\n  return !!value && value.constructor === Symbol;\n};\nconst isArray = Array.isArray;\nconst isObject = (value) => {\n  return !!value && value.constructor === Object;\n};\nconst isPrimitive = (value) => {\n  return value === void 0 || value === null || typeof value !== \"object\" && typeof value !== \"function\";\n};\nconst isFunction = (value) => {\n  return !!(value && value.constructor && value.call && value.apply);\n};\nconst isString = (value) => {\n  return typeof value === \"string\" || value instanceof String;\n};\nconst isInt = (value) => {\n  return isNumber(value) && value % 1 === 0;\n};\nconst isFloat = (value) => {\n  return isNumber(value) && value % 1 !== 0;\n};\nconst isNumber = (value) => {\n  try {\n    return Number(value) === value;\n  } catch {\n    return false;\n  }\n};\nconst isDate = (value) => {\n  return Object.prototype.toString.call(value) === \"[object Date]\";\n};\nconst isPromise = (value) => {\n  if (!value)\n    return false;\n  if (!value.then)\n    return false;\n  if (!isFunction(value.then))\n    return false;\n  return true;\n};\nconst isEmpty = (value) => {\n  if (value === true || value === false)\n    return true;\n  if (value === null || value === void 0)\n    return true;\n  if (isNumber(value))\n    return value === 0;\n  if (isDate(value))\n    return isNaN(value.getTime());\n  if (isFunction(value))\n    return false;\n  if (isSymbol(value))\n    return false;\n  const length = value.length;\n  if (isNumber(length))\n    return length === 0;\n  const size = value.size;\n  if (isNumber(size))\n    return size === 0;\n  const keys = Object.keys(value).length;\n  return keys === 0;\n};\nconst isEqual = (x, y) => {\n  if (Object.is(x, y))\n    return true;\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime();\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString();\n  }\n  if (typeof x !== \"object\" || x === null || typeof y !== \"object\" || y === null) {\n    return false;\n  }\n  const keysX = Reflect.ownKeys(x);\n  const keysY = Reflect.ownKeys(y);\n  if (keysX.length !== keysY.length)\n    return false;\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y, keysX[i]))\n      return false;\n    if (!isEqual(x[keysX[i]], y[keysX[i]]))\n      return false;\n  }\n  return true;\n};\n\nexport { isArray, isDate, isEmpty, isEqual, isFloat, isFunction, isInt, isNumber, isObject, isPrimitive, isPromise, isString, isSymbol };\n//# sourceMappingURL=typed.mjs.map\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}