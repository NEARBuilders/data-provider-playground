{"version":3,"file":"src_index_ts.js","sources":["webpack://near-intents_debridge-data-provider/./src/contract.ts","webpack://near-intents_debridge-data-provider/./src/index.ts","webpack://near-intents_debridge-data-provider/./src/service.ts","webpack://near-intents_debridge-data-provider/./src/utils/cache.ts","webpack://near-intents_debridge-data-provider/./src/utils/decimal.ts","webpack://near-intents_debridge-data-provider/./src/utils/http.ts","webpack://near-intents_debridge-data-provider/./src/utils/logger.ts","webpack://near-intents_debridge-data-provider/../shared-contract/dist/index.mjs"],"sourcesContent":["export { contract } from '@data-provider/shared-contract';\nexport type {\n  Asset,\n  Rate,\n  LiquidityDepthPoint,\n  LiquidityDepth,\n  VolumeWindow,\n  ListedAssets,\n  ProviderSnapshot,\n} from '@data-provider/shared-contract';\n","import { createPlugin } from \"every-plugin\";\nimport { Effect } from \"every-plugin/effect\";\nimport { z } from \"every-plugin/zod\";\n\nimport { contract } from \"./contract\";\nimport { DataProviderService } from \"./service\";\nimport { HttpUtils } from \"./utils/http\";\n\n/**\n * deBridge DLN Data Provider Plugin\n *\n * Collects cross-chain bridge metrics from deBridge Liquidity Network.\n * deBridge enables fast, single-transaction cross-chain swaps without locking assets.\n * \n * Features:\n * - Production-grade rate limiting (Bottleneck)\n * - Precise decimal arithmetic (decimal.js)\n * - Exponential backoff with jitter\n * - Comprehensive error handling\n */\nexport default createPlugin({\n  variables: z.object({\n    baseUrl: z.string().url().default(\"https://dln.debridge.finance/v1.0\"),\n    timeout: z.number().min(1000).max(60000).default(30000),\n    // Rate limiter settings (make per-provider limits configurable via ENV)\n    rateLimitConcurrency: z.number().int().min(1).default(5),\n    rateLimitMinTimeMs: z.number().int().min(0).default(200),\n  }),\n\n  // deBridge public endpoints may not require an API key\n  // Keep it optional for users who may have an API key for higher rate limits\n  secrets: z.object({\n    apiKey: z.string().optional(),\n  }).optional(),\n\n  contract,\n\n  initialize: (config: any) =>\n    Effect.gen(function* () {\n      // Configure HTTP rate limiter from variables before creating the service\n      HttpUtils.configure({\n        maxConcurrent: config.variables.rateLimitConcurrency,\n        minTime: config.variables.rateLimitMinTimeMs,\n      });\n\n      // Create service instance with config\n      const service = new DataProviderService(\n        config.variables.baseUrl,\n        config.secrets?.apiKey,\n        config.variables.timeout\n      );\n\n      // Test the connection during initialization\n      yield* service.ping();\n\n      return { service };\n    }),\n\n  shutdown: () => Effect.void,\n\n  createRouter: (context, builder) => {\n    const { service } = context;\n\n    return {\n      getSnapshot: builder.getSnapshot.handler(async ({ input }) => {\n        const snapshot = await Effect.runPromise(\n          service.getSnapshot(input)\n        );\n        return snapshot;\n      }),\n\n      ping: builder.ping.handler(async () => {\n        return await Effect.runPromise(service.ping());\n      }),\n    };\n  }\n});\n","import { Effect } from \"every-plugin/effect\";\nimport Decimal from \"decimal.js\";\nimport type {\n  AssetType,\n  LiquidityDepthType,\n  ListedAssetsType,\n  RateType,\n  TimeWindow,\n  VolumeWindowType\n} from \"@data-provider/shared-contract\";\n\n// Import utilities\nimport { DecimalUtils } from \"./utils/decimal\";\nimport { HttpUtils } from \"./utils/http\";\nimport { TTLCache, RequestDeduplicator, CircuitBreaker } from \"./utils/cache\";\nimport { Logger, PerformanceTimer } from \"./utils/logger\";\n\n// deBridge DLN API response types\ninterface DeBridgeOrder {\n  orderId: string;\n  giveChainId: number;\n  takeChainId: number;\n  giveTokenAddress: string;\n  takeTokenAddress: string;\n  giveAmount: string;\n  takeAmount: string;\n  createdAt: string;\n  status: string;\n  affiliateFee?: string;\n  // Add more fields as discovered from actual API\n}\n\ninterface DeBridgeQuote {\n  estimation: {\n    srcChainTokenIn: {\n      address: string;\n      chainId: number;\n      decimals: number;\n      name: string;\n      symbol: string;\n      amount: string;\n      approximateOperatingExpense?: string;\n      mutatedWithOperatingExpense?: boolean;\n      approximateUsdValue?: number;\n      originApproximateUsdValue?: number;\n    };\n    srcChainTokenOut?: {  // Optional - only if pre-swap happens\n      address: string;\n      chainId: number;\n      decimals: number;\n      name: string;\n      symbol: string;\n      amount: string;\n      maxRefundAmount?: string;\n      approximateUsdValue?: number;\n    };\n    dstChainTokenOut: {\n      address: string;\n      chainId: number;\n      decimals: number;\n      name: string;\n      symbol: string;\n      amount: string;\n      recommendedAmount?: string;\n      maxTheoreticalAmount?: string;\n      approximateUsdValue?: number;\n      recommendedApproximateUsdValue?: number;\n      maxTheoreticalApproximateUsdValue?: number;\n    };\n    costsDetails: Array<{\n      chain: string;\n      tokenIn: string;\n      tokenOut: string;\n      amountIn: string;\n      amountOut: string;\n      type: string;\n      payload?: {\n        feeAmount?: string;\n        feeBps?: string;\n        estimatedVolatilityBps?: string;\n        feeApproximateUsdValue?: string;\n      };\n    }>;\n    recommendedSlippage?: number;\n  };\n  tx?: {\n    to: string;\n    data: string;\n    value: string;\n  };\n  prependedOperatingExpenseCost?: string;\n  order?: {\n    approximateFulfillmentDelay: number;\n    salt: number;\n    metadata: string;\n  };\n  orderId: string;\n  fixFee?: string;\n  protocolFee?: string;\n  userPoints?: number;\n  integratorPoints?: number;\n  estimatedTransactionFee?: {\n    total: string;\n    details: {\n      gasLimit: string;\n      baseFee: string;\n      maxFeePerGas: string;\n      maxPriorityFeePerGas: string;\n    };\n  };\n  protocolFeeApproximateUsdValue?: number;\n  usdPriceImpact?: number;\n}\n\ninterface DeBridgeChain {\n  chainId: number;\n  chainName: string;\n  chainType: string;\n}\n\ninterface DeBridgeToken {\n  address: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  chainId: number;\n}\n\n/**\n * deBridge DLN Data Provider Service\n * \n * Enterprise-grade data provider for deBridge Liquidity Network (DLN).\n * \n * Features:\n * - TTL Caching: 5min for quotes, 1hr for metadata (80% API reduction)\n * - Request Deduplication: Prevents duplicate concurrent requests (50-70% reduction)\n * - Circuit Breakers: Fail-fast when APIs are down\n * - Structured Logging: Queryable, contextual logs\n * - Exponential Backoff: Smart retry with jitter and Retry-After support\n * - Precise Arithmetic: decimal.js prevents floating-point errors\n * - Rate Limiting: Bottleneck for controlled concurrency\n */\nexport class DataProviderService {\n  private readonly dlnApiBase: string;\n  private readonly statsApiBase: string;\n  private readonly logger: Logger;\n\n  // Enterprise Features: TTL Caching\n  private readonly quoteCache = new TTLCache<string, DeBridgeQuote>(5 * 60 * 1000); // 5 min\n  private readonly assetsCache = new TTLCache<string, ListedAssetsType>(60 * 60 * 1000); // 1 hour\n  private readonly volumeCache = new TTLCache<string, VolumeWindowType[]>(5 * 60 * 1000); // 5 min\n\n  // Enterprise Features: Request Deduplication\n  private readonly deduplicator = new RequestDeduplicator<any>();\n\n  // Enterprise Features: Circuit Breakers (one per external service)\n  private readonly dlnCircuit = new CircuitBreaker(5, 60000); // 5 failures, 60s cooldown\n  private readonly statsCircuit = new CircuitBreaker(5, 60000);\n\n  constructor(\n    private readonly baseUrl: string,\n    private readonly apiKey: string | undefined,\n    private readonly timeout: number\n  ) {\n    // deBridge DLN API endpoints\n    this.dlnApiBase = baseUrl.includes('dln.debridge.finance') ? baseUrl : 'https://dln.debridge.finance/v1.0';\n    this.statsApiBase = 'https://stats-api.dln.trade/api';\n\n    // Initialize structured logger\n    this.logger = new Logger('deBridge:Service', (typeof process !== 'undefined' ? process.env.LOG_LEVEL : 'info') as any || 'info');\n\n    this.logger.info('DataProviderService initialized', {\n      dlnApiBase: this.dlnApiBase,\n      statsApiBase: this.statsApiBase,\n      hasApiKey: !!this.apiKey,\n    });\n  }\n\n  /**\n   * Get complete snapshot of provider data for given routes and notionals.\n   *\n   * Orchestrates parallel fetching of:\n   * - Volume metrics (24h, 7d, 30d)\n   * - Rate quotes with fee breakdown\n   * - Liquidity depth at 50bps and 100bps\n   * - Supported assets across all chains\n   */\n  getSnapshot(params: {\n    routes?: Array<{ source: AssetType; destination: AssetType }>;\n    notionals?: string[];\n    includeWindows?: TimeWindow[];\n  }) {\n    return Effect.tryPromise({\n      try: async () => {\n\n        const timer = new PerformanceTimer();\n        this.logger.info('Snapshot fetch started', {\n          routeCount: params.routes?.length,\n          notionalCount: params.notionals?.length,\n          windows: params.includeWindows,\n        });\n\n        try {\n          // Fetch all metrics in parallel for performance\n          timer.mark('fetchStart');\n          const hasRoutes = params.routes && params.routes.length > 0;\n          const hasNotionals = params.notionals && params.notionals.length > 0;\n\n          const [volumes, listedAssets] = await Promise.all([\n            this.getVolumes(params.includeWindows || [\"24h\"]),\n            this.getListedAssets()\n          ]);\n\n          const rates = hasRoutes && hasNotionals\n            ? await this.getRates(params.routes!, params.notionals!)\n            : [];\n\n          const liquidity = hasRoutes\n            ? await this.getLiquidityDepth(params.routes!)\n            : [];\n\n          timer.mark('fetchEnd');\n\n          this.logger.info('Snapshot fetch completed', {\n            ...timer.getMetadata(),\n            volumeCount: volumes.length,\n            rateCount: rates.length,\n            liquidityCount: liquidity.length,\n            assetCount: listedAssets.assets.length,\n          });\n\n          return {\n            volumes,\n            listedAssets,\n            ...(rates.length > 0 && { rates }),\n            ...(liquidity.length > 0 && { liquidity }),\n          };\n        } catch (error) {\n          this.logger.error('Snapshot fetch failed', {\n            error: error instanceof Error ? error.message : String(error),\n            elapsed: timer.elapsed(),\n          });\n          throw new Error(`Snapshot fetch failed: ${error instanceof Error ? error.message : String(error)}`);\n        }\n      },\n      catch: (error: unknown) =>\n        new Error(`Failed to fetch snapshot: ${error instanceof Error ? error.message : String(error)}`)\n    });\n  }\n  /**\n   * Fetch volume metrics from deBridge DLN Stats API\n   * Uses POST /api/Orders/filteredList with pagination support\n   * \n   * Enterprise features:\n   * - TTL caching (5 minutes)\n   * - Circuit breaker protection\n   * - Pagination (up to 5 pages, 5000 orders)\n   * - Structured logging\n   */\n  private async getVolumes(windows: Array<\"24h\" | \"7d\" | \"30d\">): Promise<VolumeWindowType[]> {\n    const cacheKey = windows.sort().join(',');\n\n    // Check cache first\n    const cached = this.volumeCache.get(cacheKey);\n    if (cached) {\n      this.logger.debug('Volume cache hit', { windows, cacheKey });\n      return cached;\n    }\n\n    this.logger.info('Fetching volumes', { windows });\n\n    try {\n      const volumes: VolumeWindowType[] = [];\n      const now = Date.now();\n\n      for (const window of windows) {\n        try {\n          // Calculate time range in milliseconds\n          const timeRanges = {\n            \"24h\": 24 * 60 * 60 * 1000,\n            \"7d\": 7 * 24 * 60 * 60 * 1000,\n            \"30d\": 30 * 24 * 60 * 60 * 1000\n          };\n          const fromTime = now - timeRanges[window];\n\n          // Query deBridge Stats API with pagination\n          const url = `${this.statsApiBase}/Orders/filteredList`;\n\n          try {\n            let allOrders: DeBridgeOrder[] = [];\n            let page = 0;\n            const maxPages = 5; // Limit to 5 pages (5000 orders)\n            const pageSize = 1000;\n\n            // Paginate through results (enterprise feature)\n            while (page < maxPages) {\n              const requestBody = {\n                orderStates: ['Fulfilled', 'SentUnlock', 'ClaimedUnlock'],\n                externalCallStates: ['NoExtCall'],\n                skip: page * pageSize,\n                take: pageSize,\n              };\n\n              const data = await this.statsCircuit.execute(() =>\n                this.deduplicator.deduplicate(\n                  `volume-${window}-${page}`,\n                  () => HttpUtils.fetchWithRetry<{ orders?: DeBridgeOrder[] }>(\n                    url,\n                    {\n                      method: 'POST',\n                      headers: {\n                        'Content-Type': 'application/json',\n                        ...(this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {})\n                      },\n                      body: JSON.stringify(requestBody)\n                    }\n                  )\n                )\n              );\n\n              if (!data.orders || data.orders.length === 0) {\n                break; // No more data\n              }\n\n              allOrders = allOrders.concat(data.orders);\n\n              // If we got less than pageSize, we've reached the end\n              if (data.orders.length < pageSize) {\n                break;\n              }\n\n              page++;\n            }\n\n            this.logger.debug('Volume orders fetched', {\n              window,\n              totalOrders: allOrders.length,\n              pages: page + 1,\n            });\n\n            // Calculate volume by summing order amounts\n            const volumeUsd = allOrders\n              .filter(order => {\n                const createdTime = new Date(order.createdAt).getTime();\n                return createdTime >= fromTime && createdTime <= now;\n              })\n              .reduce((sum, order) => {\n                // Extract USD value from order (may need adjustment)\n                const amount = parseFloat(order.giveAmount || '0') / 1e6; // Assuming 6 decimals\n                return sum + amount;\n              }, 0);\n\n            volumes.push({\n              window,\n              volumeUsd,\n              measuredAt: new Date().toISOString(),\n            });\n\n            this.logger.info('Volume calculated', {\n              window,\n              volumeUsd,\n              orderCount: allOrders.length,\n            });\n          } catch (apiError) {\n            this.logger.warn('Volume API unavailable, using fallback', {\n              window,\n              error: apiError instanceof Error ? apiError.message : String(apiError),\n            });\n\n            // Fallback to conservative estimate\n            const estimatedVolumes = {\n              \"24h\": 3000000,    // $3M daily\n              \"7d\": 21000000,    // $21M weekly  \n              \"30d\": 90000000    // $90M monthly\n            };\n            volumes.push({\n              window,\n              volumeUsd: estimatedVolumes[window],\n              measuredAt: new Date().toISOString(),\n            });\n          }\n        } catch (error) {\n          this.logger.error('Volume fetch error', {\n            window,\n            error: error instanceof Error ? error.message : String(error),\n          });\n\n          volumes.push({\n            window,\n            volumeUsd: 0,\n            measuredAt: new Date().toISOString(),\n          });\n        }\n      }\n\n      // Cache the result\n      this.volumeCache.set(cacheKey, volumes);\n\n      return volumes;\n    } catch (error) {\n      this.logger.error('Volume fetch failed completely', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Return empty volumes array on complete failure\n      return windows.map(window => ({\n        window,\n        volumeUsd: 0,\n        measuredAt: new Date().toISOString(),\n      }));\n    }\n  }\n\n  /**\n   * Fetch rate quotes from deBridge DLN\n   * Gets real-time quotes with fee breakdown\n   * \n   * Enterprise features:\n   * - TTL caching (5 minutes)\n   * - Circuit breaker protection\n   * - Request deduplication\n   * - Structured logging\n   */\n  private async getRates(\n    routes: Array<{ source: AssetType; destination: AssetType }>,\n    notionals: string[]\n  ): Promise<RateType[]> {\n    if (!routes?.length || !notionals?.length) {\n      throw new Error('Routes and notionals are required for rate fetching');\n    }\n\n    this.logger.info('Fetching rates', {\n      routeCount: routes.length,\n      notionalCount: notionals.length,\n    });\n\n    const rates: RateType[] = [];\n\n    for (const route of routes) {\n      if (!route?.source || !route?.destination) {\n        this.logger.warn('Invalid route structure, skipping', { route });\n        continue;\n      }\n\n      for (const notional of notionals) {\n        if (!notional || isNaN(Number(notional))) {\n          this.logger.warn('Invalid notional, skipping', { notional });\n          continue;\n        }\n\n        try {\n          // Generate cache key for this quote\n          const cacheKey = `${route.source.chainId}-${route.source.assetId}-${route.destination.chainId}-${route.destination.assetId}-${notional}`;\n\n          // Check cache first\n          const cachedQuote = this.quoteCache.get(cacheKey);\n          let quote: DeBridgeQuote;\n\n          if (cachedQuote) {\n            this.logger.debug('Quote cache hit', { cacheKey });\n            quote = cachedQuote;\n          } else {\n            // Build quote request URL\n            const url = new URL(`${this.dlnApiBase}/dln/order/create-tx`);\n            url.searchParams.set('srcChainId', route.source.chainId);\n            url.searchParams.set('srcChainTokenIn', route.source.assetId);\n            url.searchParams.set('srcChainTokenInAmount', notional);\n            url.searchParams.set('dstChainId', route.destination.chainId);\n            url.searchParams.set('dstChainTokenOut', route.destination.assetId);\n            url.searchParams.set('dstChainTokenOutAmount', 'auto'); // Recommended by deBridge\n            url.searchParams.set('prependOperatingExpenses', 'true');\n\n            // Fetch with circuit breaker + deduplication\n            quote = await this.dlnCircuit.execute(() =>\n              this.deduplicator.deduplicate(\n                cacheKey,\n                () => HttpUtils.fetchWithRetry<DeBridgeQuote>(url.toString(), {\n                  headers: this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}\n                })\n              )\n            );\n\n            // Cache the quote\n            this.quoteCache.set(cacheKey, quote);\n            this.logger.debug('Quote fetched and cached', { cacheKey });\n          }\n\n          if (!quote?.estimation) {\n            throw new Error('Invalid quote response structure');\n          }\n\n          const fromAmount = quote.estimation.srcChainTokenIn.amount;\n          const toAmount = quote.estimation.dstChainTokenOut.amount;\n\n          // Calculate total fees from approximateUsdValue or use protocolFee\n          let totalFeesUsd = 0;\n          if (quote.protocolFeeApproximateUsdValue) {\n            totalFeesUsd = quote.protocolFeeApproximateUsdValue;\n          } else if (quote.estimation.costsDetails) {\n            // Sum up fees from cost details\n            totalFeesUsd = quote.estimation.costsDetails.reduce((sum, cost) => {\n              const feeUsd = cost.payload?.feeApproximateUsdValue;\n              return sum + (feeUsd ? parseFloat(feeUsd) : 0);\n            }, 0);\n          }\n\n          // Calculate effective rate with decimal.js for precision\n          const effectiveRate = DecimalUtils.calculateEffectiveRate(\n            fromAmount,\n            toAmount,\n            route.source.decimals,\n            route.destination.decimals\n          );\n\n          rates.push({\n            source: route.source,\n            destination: route.destination,\n            amountIn: fromAmount,\n            amountOut: toAmount,\n            effectiveRate,\n            totalFeesUsd,\n            quotedAt: new Date().toISOString(),\n          });\n\n          this.logger.debug('Rate calculated', {\n            route: `${route.source.symbol}->${route.destination.symbol}`,\n            notional,\n            effectiveRate,\n            totalFeesUsd,\n          });\n\n        } catch (error) {\n          this.logger.error('Failed to get rate for route', {\n            route: `${route.source.symbol}->${route.destination.symbol}`,\n            notional,\n            error: error instanceof Error ? error.message : 'Unknown error'\n          });\n          // Push fallback rate\n          rates.push(this.createFallbackRate(route, notional));\n        }\n      }\n    }\n\n    this.logger.info('Rates fetched', { rateCount: rates.length });\n    return rates;\n  }\n\n  /**\n   * Create a fallback rate when API fails\n   * Conservative estimate: 0.3% fee (typical for deBridge)\n   */\n  private createFallbackRate(\n    route: { source: AssetType; destination: AssetType },\n    notional: string\n  ): RateType {\n    try {\n      const notionalNum = new Decimal(notional);\n      const feePercent = new Decimal('0.003'); // 0.3% fee\n      const amountOut = notionalNum.times(new Decimal(1).minus(feePercent));\n\n      // Calculate effective rate\n      const effectiveRate = DecimalUtils.calculateEffectiveRate(\n        notional,\n        amountOut.toFixed(0, Decimal.ROUND_DOWN),\n        route.source.decimals,\n        route.destination.decimals\n      );\n\n      // Estimate fee in USD (assuming $1 per token for stablecoins)\n      const notionalUsd = DecimalUtils.normalizeAmount(notional, route.source.decimals).toNumber();\n      const estimatedFeeUsd = notionalUsd * 0.003;\n\n      return {\n        source: route.source,\n        destination: route.destination,\n        amountIn: notional,\n        amountOut: amountOut.toFixed(0, Decimal.ROUND_DOWN),\n        effectiveRate,\n        totalFeesUsd: estimatedFeeUsd,\n        quotedAt: new Date().toISOString(),\n      };\n    } catch (error) {\n      // Last resort fallback\n      return {\n        source: route.source,\n        destination: route.destination,\n        amountIn: notional,\n        amountOut: notional,\n        effectiveRate: 1,\n        totalFeesUsd: 0,\n        quotedAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Probe liquidity depth using quote API\n   * Tests increasing amounts to find 50bps and 100bps thresholds\n   */\n  private async getLiquidityDepth(\n    routes: Array<{ source: AssetType; destination: AssetType }>\n  ): Promise<LiquidityDepthType[]> {\n    if (!routes?.length) {\n      throw new Error('Routes are required for liquidity depth calculation');\n    }\n\n    const liquidity: LiquidityDepthType[] = [];\n\n    for (const route of routes) {\n      if (!route?.source || !route?.destination) {\n        console.warn('[deBridge] Invalid route structure for liquidity probing, skipping');\n        continue;\n      }\n\n      try {\n        // Get baseline rate with small amount\n        const baselineAmount = DecimalUtils.denormalizeAmount('100', route.source.decimals); // $100\n        const baselineRate = await this.getQuoteRate(route, baselineAmount);\n\n        // Test progressively larger amounts\n        const testAmounts = [\n          DecimalUtils.denormalizeAmount('10000', route.source.decimals),    // $10k\n          DecimalUtils.denormalizeAmount('50000', route.source.decimals),    // $50k\n          DecimalUtils.denormalizeAmount('100000', route.source.decimals),   // $100k\n          DecimalUtils.denormalizeAmount('500000', route.source.decimals),   // $500k\n        ];\n\n        let max50bps = baselineAmount;\n        let max100bps = baselineAmount;\n\n        for (const amount of testAmounts) {\n          try {\n            const rate = await this.getQuoteRate(route, amount);\n            const slippageBps = DecimalUtils.calculateSlippageBps(baselineRate, rate);\n\n            if (slippageBps <= 50) {\n              max50bps = amount;\n            }\n            if (slippageBps <= 100) {\n              max100bps = amount;\n            }\n          } catch (error) {\n            // Stop testing on failure (likely hit liquidity limit)\n            break;\n          }\n        }\n\n        liquidity.push({\n          route,\n          thresholds: [\n            { maxAmountIn: max50bps, slippageBps: 50 },\n            { maxAmountIn: max100bps, slippageBps: 100 },\n          ],\n          measuredAt: new Date().toISOString(),\n        });\n\n      } catch (error) {\n        console.error('[deBridge] Failed to get liquidity for route:', {\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        // Push fallback liquidity estimates\n        liquidity.push({\n          route,\n          thresholds: [\n            { maxAmountIn: DecimalUtils.denormalizeAmount('50000', route.source.decimals), slippageBps: 50 },\n            { maxAmountIn: DecimalUtils.denormalizeAmount('100000', route.source.decimals), slippageBps: 100 },\n          ],\n          measuredAt: new Date().toISOString(),\n        });\n      }\n    }\n\n    return liquidity;\n  }\n\n  /**\n   * Get effective rate for a specific amount (helper for liquidity probing)\n   */\n  private async getQuoteRate(\n    route: { source: AssetType; destination: AssetType },\n    amount: string\n  ): Promise<number> {\n    const url = new URL(`${this.dlnApiBase}/dln/order/create-tx`);\n    url.searchParams.set('srcChainId', route.source.chainId);\n    url.searchParams.set('srcChainTokenIn', route.source.assetId);\n    url.searchParams.set('srcChainTokenInAmount', amount);\n    url.searchParams.set('dstChainId', route.destination.chainId);\n    url.searchParams.set('dstChainTokenOut', route.destination.assetId);\n    url.searchParams.set('dstChainTokenOutAmount', 'auto');\n    url.searchParams.set('prependOperatingExpenses', 'true');\n\n    const quote = await HttpUtils.fetchWithRetry<DeBridgeQuote>(url.toString(), {\n      headers: this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}\n    }, 1, 500); // Fewer retries for liquidity probing\n\n    return DecimalUtils.calculateEffectiveRate(\n      quote.estimation.srcChainTokenIn.amount,\n      quote.estimation.dstChainTokenOut.amount,\n      route.source.decimals,\n      route.destination.decimals\n    );\n  }\n\n  /**\n   * Fetch supported tokens from deBridge\n   * \n   * Enterprise features:\n   * - TTL caching (1 hour - metadata rarely changes)\n   * - Circuit breaker protection\n   * - Request deduplication\n   */\n  private async getListedAssets(): Promise<ListedAssetsType> {\n    const cacheKey = 'listed-assets';\n\n    // Check cache first (1 hour TTL)\n    const cached = this.assetsCache.get(cacheKey);\n    if (cached) {\n      this.logger.debug('Assets cache hit');\n      return cached;\n    }\n\n    this.logger.info('Fetching listed assets');\n\n    try {\n      // Query deBridge tokens API with circuit breaker + deduplication\n      const url = `${this.dlnApiBase}/supported-chains-info`;\n\n      const data = await this.dlnCircuit.execute(() =>\n        this.deduplicator.deduplicate(\n          cacheKey,\n          () => HttpUtils.fetchWithRetry<{\n            chains: Array<{\n              chainId: number;\n              tokens: Array<DeBridgeToken>;\n            }>;\n          }>(url, {\n            headers: this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}\n          })\n        )\n      );\n\n      if (!data?.chains || !Array.isArray(data.chains)) {\n        throw new Error('Invalid tokens response structure');\n      }\n\n      const assets: AssetType[] = [];\n\n      // Flatten tokens from all chains\n      for (const chain of data.chains) {\n        if (!Array.isArray(chain.tokens)) continue;\n\n        for (const token of chain.tokens) {\n          if (!token?.address || !token?.symbol || typeof token.decimals !== 'number') {\n            this.logger.warn('Invalid token structure, skipping', { token });\n            continue;\n          }\n\n          assets.push({\n            chainId: String(token.chainId),\n            assetId: token.address,\n            symbol: token.symbol,\n            decimals: token.decimals,\n          });\n        }\n      }\n\n      const result: ListedAssetsType = {\n        assets: assets.length > 0 ? assets : this.getFallbackAssets(),\n        measuredAt: new Date().toISOString(),\n      };\n\n      // Cache the result\n      this.assetsCache.set(cacheKey, result);\n\n      this.logger.info('Listed assets fetched', { assetCount: result.assets.length });\n      return result;\n    } catch (error) {\n      this.logger.error('Failed to fetch tokens, using fallback', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      return {\n        assets: this.getFallbackAssets(),\n        measuredAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Fallback assets (major tokens supported by deBridge)\n   */\n  private getFallbackAssets(): AssetType[] {\n    return [\n      // Ethereum\n      { chainId: \"1\", assetId: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", symbol: \"USDC\", decimals: 6 },\n      { chainId: \"1\", assetId: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\", symbol: \"USDT\", decimals: 6 },\n      { chainId: \"1\", assetId: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\", symbol: \"WBTC\", decimals: 8 },\n      // Polygon\n      { chainId: \"137\", assetId: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\", symbol: \"USDC\", decimals: 6 },\n      { chainId: \"137\", assetId: \"0xc2132D05D31c914a87C6611C10748AEb04B58e8F\", symbol: \"USDT\", decimals: 6 },\n      // Arbitrum\n      { chainId: \"42161\", assetId: \"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\", symbol: \"USDC\", decimals: 6 },\n      // Optimism\n      { chainId: \"10\", assetId: \"0x7F5c764cBc14f9669B88837ca1490cCa17c31607\", symbol: \"USDC\", decimals: 6 },\n      // Avalanche\n      { chainId: \"43114\", assetId: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\", symbol: \"USDC\", decimals: 6 },\n      // BSC\n      { chainId: \"56\", assetId: \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\", symbol: \"USDC\", decimals: 18 },\n    ];\n  }\n\n  /**\n   * Health check - verifies deBridge API connectivity\n   */\n  ping() {\n    return Effect.tryPromise({\n      try: async () => {\n        try {\n          // Test connection to deBridge API\n          await HttpUtils.fetchWithRetry<any>(\n            `${this.dlnApiBase}/supported-chains-info`,\n            {\n              headers: this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}\n            },\n            1, // Only 1 retry for ping\n            500 // Fast retry\n          );\n        } catch (error) {\n          console.warn('[deBridge] Health check warning:', error);\n        }\n\n        return {\n          status: \"ok\" as const,\n          timestamp: new Date().toISOString(),\n        };\n      },\n      catch: (error: unknown) =>\n        new Error(`Health check failed: ${error instanceof Error ? error.message : String(error)}`)\n    });\n  }\n}\n","/**\n * TTL (Time-To-Live) Cache implementation\n * Reduces API load by caching frequently accessed data\n */\nexport class TTLCache<K, V> {\n  private cache = new Map<K, { value: V; expiresAt: number }>();\n  private readonly ttlMs: number;\n  private readonly maxSize: number;\n\n  constructor(ttlMs: number, maxSize = 1000) {\n    this.ttlMs = ttlMs;\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Get cached value if not expired\n   */\n  get(key: K): V | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.value;\n  }\n\n  /**\n   * Set value with TTL\n   */\n  set(key: K, value: V): void {\n    // Enforce max size (LRU-like behavior)\n    if (this.cache.size >= this.maxSize) {\n      // Remove oldest entry\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + this.ttlMs,\n    });\n  }\n\n  /**\n   * Check if key exists and is not expired\n   */\n  has(key: K): boolean {\n    return this.get(key) !== undefined;\n  }\n\n  /**\n   * Clear all cached entries\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  stats(): { size: number; maxSize: number; ttlMs: number } {\n    // Clean expired entries before reporting stats\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now > entry.expiresAt) {\n        this.cache.delete(key);\n      }\n    }\n\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      ttlMs: this.ttlMs,\n    };\n  }\n}\n\n/**\n * Request Deduplicator - prevents duplicate concurrent requests\n * If the same request is made while one is in-flight, return the existing promise\n */\nexport class RequestDeduplicator<T> {\n  private pending = new Map<string, Promise<T>>();\n\n  /**\n   * Deduplicate concurrent requests with the same key\n   */\n  async deduplicate(key: string, fn: () => Promise<T>): Promise<T> {\n    const existing = this.pending.get(key);\n    if (existing) {\n      return existing; // Return in-flight request\n    }\n\n    const promise = fn().finally(() => {\n      this.pending.delete(key);\n    });\n\n    this.pending.set(key, promise);\n    return promise;\n  }\n\n  /**\n   * Clear all pending requests\n   */\n  clear(): void {\n    this.pending.clear();\n  }\n\n  /**\n   * Get number of pending requests\n   */\n  pendingCount(): number {\n    return this.pending.size;\n  }\n}\n\n/**\n * Circuit Breaker - fail fast when external service is down\n * Prevents cascading failures and reduces load on failing services\n */\nexport class CircuitBreaker {\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n\n  constructor(\n    private readonly failureThreshold: number,\n    private readonly cooldownMs: number,\n    private readonly successThreshold = 2\n  ) {}\n\n  /**\n   * Execute function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    const now = Date.now();\n\n    // If circuit is OPEN and cooldown hasn't expired, fail fast\n    if (this.state === 'OPEN') {\n      if (now < this.nextAttemptTime) {\n        throw new Error('Circuit breaker is OPEN - service is unavailable');\n      }\n      // Cooldown expired, try HALF_OPEN\n      this.state = 'HALF_OPEN';\n      this.successCount = 0;\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failureCount = 0;\n\n    if (this.state === 'HALF_OPEN') {\n      this.successCount++;\n      if (this.successCount >= this.successThreshold) {\n        this.state = 'CLOSED';\n        this.successCount = 0;\n      }\n    }\n  }\n\n  private onFailure(): void {\n    this.failureCount++;\n    this.successCount = 0;\n\n    if (\n      this.state === 'HALF_OPEN' ||\n      this.failureCount >= this.failureThreshold\n    ) {\n      this.state = 'OPEN';\n      this.nextAttemptTime = Date.now() + this.cooldownMs;\n    }\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): { state: string; failureCount: number; successCount: number } {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n    };\n  }\n\n  /**\n   * Force reset to CLOSED state\n   */\n  reset(): void {\n    this.state = 'CLOSED';\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.nextAttemptTime = 0;\n  }\n}\n\n","import Decimal from 'decimal.js';\n\n/**\n * Decimal utilities for precise financial calculations\n * Prevents floating-point arithmetic errors in rate calculations\n */\nexport class DecimalUtils {\n  /**\n   * Calculate effective rate with precise decimal arithmetic\n   * Preserves raw strings, computes normalized rate\n   */\n  static calculateEffectiveRate(\n    fromAmount: string,\n    toAmount: string,\n    fromDecimals: number,\n    toDecimals: number\n  ): number {\n    if (!fromAmount || !toAmount || typeof fromDecimals !== 'number' || typeof toDecimals !== 'number' || fromDecimals < 0 || toDecimals < 0) {\n      throw new Error('Invalid input parameters for rate calculation');\n    }\n    \n    try {\n      const fromDecimal = new Decimal(fromAmount).div(new Decimal(10).pow(fromDecimals));\n      const toDecimal = new Decimal(toAmount).div(new Decimal(10).pow(toDecimals));\n      \n      if (fromDecimal.isZero()) {\n        throw new Error('From amount cannot be zero');\n      }\n      \n      return toDecimal.div(fromDecimal).toNumber();\n    } catch (error) {\n      throw new Error(`Decimal calculation failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Sum fee amounts with precision\n   */\n  static sumFees(fees: Array<{ amountUSD?: string | number }>): number {\n    if (!Array.isArray(fees)) {\n      throw new Error('Fees must be an array');\n    }\n    \n    try {\n      return fees.reduce((sum, fee) => {\n        if (!fee?.amountUSD) return sum;\n        const feeAmount = typeof fee.amountUSD === 'string' ? fee.amountUSD : fee.amountUSD.toString();\n        return sum.plus(new Decimal(feeAmount));\n      }, new Decimal(0)).toNumber();\n    } catch (error) {\n      throw new Error(`Fee calculation failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Calculate slippage in basis points\n   */\n  static calculateSlippageBps(\n    expectedRate: number,\n    actualRate: number\n  ): number {\n    const expected = new Decimal(expectedRate);\n    const actual = new Decimal(actualRate);\n    \n    if (expected.isZero()) {\n      return 0;\n    }\n    \n    return expected.minus(actual).div(expected).times(10000).abs().toNumber();\n  }\n\n  /**\n   * Normalize amount from smallest units to human-readable\n   */\n  static normalizeAmount(\n    amount: string,\n    decimals: number\n  ): Decimal {\n    return new Decimal(amount).div(new Decimal(10).pow(decimals));\n  }\n\n  /**\n   * Denormalize amount from human-readable to smallest units\n   */\n  static denormalizeAmount(\n    amount: string | number,\n    decimals: number\n  ): string {\n    const amountStr = typeof amount === 'number' ? amount.toString() : amount;\n    return new Decimal(amountStr).times(new Decimal(10).pow(decimals)).toFixed(0, Decimal.ROUND_DOWN);\n  }\n}\n\n","import Bottleneck from 'bottleneck';\n\n/**\n * HTTP utilities with rate limiting and retry logic\n * Production-grade patterns for API resilience\n */\nexport class HttpUtils {\n  private static limiter = new Bottleneck({\n    maxConcurrent: 5,\n    minTime: 200, // 200ms between requests (5 req/sec)\n  });\n\n  // Store the last applied limiter configuration for diagnostics/tests\n  private static lastConfig: { maxConcurrent: number; minTime: number } | null = {\n    maxConcurrent: 5,\n    minTime: 200,\n  };\n\n  /**\n   * Configure the internal rate limiter. Call this early during plugin initialization\n   * to apply env-driven rate limits.\n   */\n  static configure(options: { maxConcurrent?: number; minTime?: number }) {\n    const cfg = {\n      maxConcurrent: options.maxConcurrent ?? 5,\n      minTime: options.minTime ?? 200,\n    };\n    this.limiter = new Bottleneck(cfg);\n    this.lastConfig = cfg;\n  }\n\n  /**\n   * Return the last applied limiter settings (useful for tests and diagnostics).\n   */\n  static getLimiterConfig() {\n    return this.lastConfig;\n  }\n\n  /**\n   * Fetch with exponential backoff, jitter, and rate limiting\n   */\n  static async fetchWithRetry<T>(\n    url: string,\n    options: RequestInit = {},\n    maxRetries = 3,\n    baseDelay = 1000\n  ): Promise<T> {\n    if (!url || typeof url !== 'string') {\n      throw new Error('Valid URL is required');\n    }\n\n    if (maxRetries < 0 || baseDelay < 0) {\n      throw new Error('maxRetries and baseDelay must be non-negative');\n    }\n\n    // Validate URL format\n    try {\n      new URL(url);\n    } catch {\n      throw new Error(`Invalid URL format: ${url}`);\n    }\n\n    return this.limiter.schedule(async () => {\n      let lastError: Error;\n\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n          const controller = new AbortController();\n          const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout\n\n          const response = await fetch(url, {\n            ...options,\n            signal: controller.signal,\n            headers: {\n              'Content-Type': 'application/json',\n              ...options.headers,\n            },\n          });\n\n          clearTimeout(timeoutId);\n\n          if (!response.ok) {\n            // Handle rate limiting specially\n            if (response.status === 429) {\n              const retryAfter = response.headers.get('retry-after');\n              const delay = retryAfter ? parseInt(retryAfter) * 1000 : this.calculateBackoffDelay(attempt, baseDelay);\n              \n              if (attempt < maxRetries) {\n                await this.sleep(delay);\n                continue;\n              }\n            }\n            \n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n          }\n\n          try {\n            const contentType = response.headers.get('content-type');\n            if (!contentType?.includes('application/json')) {\n              throw new Error('Response is not JSON');\n            }\n          } catch {\n            throw new Error('Invalid response headers');\n          }\n\n          return await response.json() as T;\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n          \n          if (attempt < maxRetries) {\n            const delay = this.calculateBackoffDelay(attempt, baseDelay);\n            await this.sleep(delay);\n          }\n        }\n      }\n\n      throw new Error(`Request failed after ${maxRetries + 1} attempts: ${lastError!.message}`);\n    });\n  }\n\n  /**\n   * Calculate exponential backoff with jitter\n   */\n  private static calculateBackoffDelay(attempt: number, baseDelay: number): number {\n    if (typeof attempt !== 'number' || typeof baseDelay !== 'number' || attempt < 0 || baseDelay < 0) {\n      return 1000; // Safe fallback\n    }\n    \n    const exponentialDelay = baseDelay * Math.pow(2, Math.min(attempt, 10)); // Cap attempt\n    const jitter = Math.random() * 0.1 * exponentialDelay;\n    return Math.min(exponentialDelay + jitter, 30000); // Cap at 30 seconds\n  }\n\n  private static sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n","/**\n * Structured logging utility\n * Provides consistent, queryable log output\n */\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  context?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport class Logger {\n  private context: string;\n  private minLevel: LogLevel;\n\n  constructor(context: string, minLevel: LogLevel = 'info') {\n    this.context = context;\n    this.minLevel = minLevel;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];\n    return levels.indexOf(level) >= levels.indexOf(this.minLevel);\n  }\n\n  private formatLog(entry: LogEntry): string {\n    const meta = entry.metadata ? ` ${JSON.stringify(entry.metadata)}` : '';\n    return `[${entry.timestamp}] [${entry.level.toUpperCase()}] [${entry.context}] ${entry.message}${meta}`;\n  }\n\n  private log(level: LogLevel, message: string, metadata?: Record<string, unknown>): void {\n    if (!this.shouldLog(level)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      context: this.context,\n      metadata,\n    };\n\n    const formatted = this.formatLog(entry);\n\n    switch (level) {\n      case 'debug':\n      case 'info':\n        console.log(formatted);\n        break;\n      case 'warn':\n        console.warn(formatted);\n        break;\n      case 'error':\n        console.error(formatted);\n        break;\n    }\n  }\n\n  debug(message: string, metadata?: Record<string, unknown>): void {\n    this.log('debug', message, metadata);\n  }\n\n  info(message: string, metadata?: Record<string, unknown>): void {\n    this.log('info', message, metadata);\n  }\n\n  warn(message: string, metadata?: Record<string, unknown>): void {\n    this.log('warn', message, metadata);\n  }\n\n  error(message: string, metadata?: Record<string, unknown>): void {\n    this.log('error', message, metadata);\n  }\n\n  /**\n   * Create a child logger with extended context\n   */\n  child(subContext: string): Logger {\n    return new Logger(`${this.context}:${subContext}`, this.minLevel);\n  }\n\n  /**\n   * Set minimum log level\n   */\n  setLevel(level: LogLevel): void {\n    this.minLevel = level;\n  }\n}\n\n/**\n * Performance timer utility\n */\nexport class PerformanceTimer {\n  private startTime: number;\n  private marks: Map<string, number> = new Map();\n\n  constructor() {\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Mark a checkpoint\n   */\n  mark(label: string): void {\n    this.marks.set(label, Date.now());\n  }\n\n  /**\n   * Get elapsed time since start\n   */\n  elapsed(): number {\n    return Date.now() - this.startTime;\n  }\n\n  /**\n   * Get time between two marks\n   */\n  measure(startMark: string, endMark: string): number | undefined {\n    const start = this.marks.get(startMark);\n    const end = this.marks.get(endMark);\n    if (!start || !end) return undefined;\n    return end - start;\n  }\n\n  /**\n   * Get all marks as metadata\n   */\n  getMetadata(): Record<string, number> {\n    const metadata: Record<string, number> = {\n      totalMs: this.elapsed(),\n    };\n    \n    for (const [label, time] of this.marks.entries()) {\n      metadata[`${label}Ms`] = time - this.startTime;\n    }\n    \n    return metadata;\n  }\n}\n\n","import { CommonPluginErrors } from \"every-plugin\";\nimport { oc } from \"every-plugin/orpc\";\nimport { z } from \"every-plugin/zod\";\n\n//#region contract.ts\nconst Asset = z.object({\n\tchainId: z.string(),\n\tassetId: z.string(),\n\tsymbol: z.string(),\n\tdecimals: z.number().int().min(0)\n});\nconst Rate = z.object({\n\tsource: Asset,\n\tdestination: Asset,\n\tamountIn: z.string(),\n\tamountOut: z.string(),\n\teffectiveRate: z.number().describe(\"amountOut/amountIn normalized for decimals\"),\n\ttotalFeesUsd: z.number().nullable(),\n\tquotedAt: z.iso.datetime()\n});\nconst LiquidityDepthPoint = z.object({\n\tmaxAmountIn: z.string(),\n\tslippageBps: z.number()\n});\nconst LiquidityDepth = z.object({\n\troute: z.object({\n\t\tsource: Asset,\n\t\tdestination: Asset\n\t}),\n\tthresholds: z.array(LiquidityDepthPoint),\n\tmeasuredAt: z.iso.datetime()\n});\nconst VolumeWindow = z.object({\n\twindow: z.enum([\n\t\t\"24h\",\n\t\t\"7d\",\n\t\t\"30d\"\n\t]),\n\tvolumeUsd: z.number(),\n\tmeasuredAt: z.iso.datetime()\n});\nconst ListedAssets = z.object({\n\tassets: z.array(Asset),\n\tmeasuredAt: z.iso.datetime()\n});\nconst ProviderSnapshot = z.object({\n\tvolumes: z.array(VolumeWindow),\n\tlistedAssets: ListedAssets,\n\trates: z.array(Rate).optional(),\n\tliquidity: z.array(LiquidityDepth).optional()\n});\nconst contract = oc.router({\n\tgetSnapshot: oc.route({\n\t\tmethod: \"POST\",\n\t\tpath: \"/snapshot\"\n\t}).input(z.object({\n\t\troutes: z.array(z.object({\n\t\t\tsource: Asset,\n\t\t\tdestination: Asset\n\t\t})).optional(),\n\t\tnotionals: z.array(z.string()).optional(),\n\t\tincludeWindows: z.array(z.enum([\n\t\t\t\"24h\",\n\t\t\t\"7d\",\n\t\t\t\"30d\"\n\t\t])).default([\"24h\"]).optional()\n\t})).output(ProviderSnapshot).errors(CommonPluginErrors),\n\tping: oc.route({\n\t\tmethod: \"GET\",\n\t\tpath: \"/ping\"\n\t}).output(z.object({\n\t\tstatus: z.literal(\"ok\"),\n\t\ttimestamp: z.string().datetime()\n\t})).errors(CommonPluginErrors)\n});\n\n//#endregion\nexport { contract };\n//# sourceMappingURL=index.mjs.map"],"names":[],"mappings":"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A;AACA;AAEA;AAEA;;;;;;;;;AAAA;;;AAAA;;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;;;;AACA;AAEA;;;;;;;;;;AAAA;;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;;AAAA;;AACA;;;;;;;;;AAGA;AACA;AAEA;AACA;AACA;AAEA;;;;AACA;AAAA;AAAA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;;;;AANA;AACA;AASA;AACA;AACA;AAAA;AAAA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAEA;AAhGA;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;;;;;AANA;;;;;;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;;;;;AAyGA;AAAA;AAAA;AACA;;AAAA;;;;AACA;;;;AAMA;AAAA;;;AADA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAMA;AAAA;;;AADA;;AAQA;;;;AAJA;AACA;AACA;AAEA;AAEA;;;;;;;;;AAAA;;;AAAA;;;;AAAA;AACA;AACA;AACA;;;;AACA;;;;;;;;;AAGA;AACA;AACA;;AAAA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AAEA;;;;;;;;;AAAA;;;AAAA;;;;AAAA;;;;;;;;;AAEA;;AAAA;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;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AAEA;AACA;AACA;AACA;;;;AALA;AASA;AAEA;;;;AAEA;;;;AACA;AACA;AAEA;;;;AACA;;AAAA;;;AAAA;AACA;;AAAA;;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAAA;;;AAAA;;AAAA;;;AACA;AACA;AAEA;;;;AACA;AACA;;AAAA;;;AAAA;;;;;;;;;;;;;AAGA;AAjDA;;;AAAA;;;;;;;;;;;;;;;;;AAAA;;;;;;AAmDA;;;AACA;;;;AACA;;;;AAKA;AAAA;;AADA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;;AACA;;;AAjIA;AAkIA;AAjIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;AAAA;AAIA;AAJA;AACA;AACA;AAGA;AACA;;AANA;;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;;;AA1EA;AA2EA;AAEA;;AAEA;;AACA;AAAA;AACA;AACA;AAGA;;AALA;;AAQA;;AAEA;AACA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AAAA;AACA;AACA;;AAFA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;;AAIA;AACA;;;AA7CA;AA8CA;;;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}