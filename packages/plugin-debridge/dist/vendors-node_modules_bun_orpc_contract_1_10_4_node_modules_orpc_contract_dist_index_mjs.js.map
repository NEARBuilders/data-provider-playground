{"version":3,"file":"vendors-node_modules_bun_orpc_contract_1_10_4_node_modules_orpc_contract_dist_index_mjs.js","sources":["webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+contract@1.10.4/node_modules/@orpc/contract/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+contract@1.10.4/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs"],"sourcesContent":["import { preventNativeAwait, isTypescriptObject } from '@orpc/shared';\nexport { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, asyncIteratorToUnproxiedDataStream as eventIteratorToUnproxiedDataStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';\nimport { i as isDefinedError } from './shared/client.DmkMd_GB.mjs';\nexport { C as COMMON_ORPC_ERROR_DEFS, c as ORPCError, O as ORPC_CLIENT_PACKAGE_NAME, a as ORPC_CLIENT_PACKAGE_VERSION, g as createORPCErrorFromJson, b as fallbackORPCErrorMessage, f as fallbackORPCErrorStatus, e as isORPCErrorJson, d as isORPCErrorStatus, m as mapEventIterator, t as toORPCError } from './shared/client.DmkMd_GB.mjs';\nexport { ErrorEvent } from '@orpc/standard-server';\n\nasync function safe(promise) {\n  try {\n    const output = await promise;\n    return Object.assign(\n      [null, output, false, true],\n      { error: null, data: output, isDefined: false, isSuccess: true }\n    );\n  } catch (e) {\n    const error = e;\n    if (isDefinedError(error)) {\n      return Object.assign(\n        [error, void 0, true, false],\n        { error, data: void 0, isDefined: true, isSuccess: false }\n      );\n    }\n    return Object.assign(\n      [error, void 0, false, false],\n      { error, data: void 0, isDefined: false, isSuccess: false }\n    );\n  }\n}\nfunction resolveFriendlyClientOptions(options) {\n  return {\n    ...options,\n    context: options.context ?? {}\n    // Context only optional if all fields are optional\n  };\n}\nfunction consumeEventIterator(iterator, options) {\n  void (async () => {\n    let onFinishState;\n    try {\n      const resolvedIterator = await iterator;\n      while (true) {\n        const { done, value } = await resolvedIterator.next();\n        if (done) {\n          const realValue = value;\n          onFinishState = [null, realValue, true];\n          options.onSuccess?.(realValue);\n          break;\n        }\n        options.onEvent(value);\n      }\n    } catch (error) {\n      onFinishState = [error, void 0, false];\n      if (!options.onError && !options.onFinish) {\n        throw error;\n      }\n      options.onError?.(error);\n    } finally {\n      options.onFinish?.(onFinishState);\n    }\n  })();\n  return async () => {\n    await (await iterator)?.return?.();\n  };\n}\n\nfunction createORPCClient(link, options = {}) {\n  const path = options.path ?? [];\n  const procedureClient = async (...[input, options2 = {}]) => {\n    return await link.call(path, input, resolveFriendlyClientOptions(options2));\n  };\n  const recursive = new Proxy(procedureClient, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      return createORPCClient(link, {\n        ...options,\n        path: [...path, key]\n      });\n    }\n  });\n  return preventNativeAwait(recursive);\n}\n\nfunction createSafeClient(client) {\n  const proxy = new Proxy((...args) => safe(client(...args)), {\n    get(_, prop, receiver) {\n      const value = Reflect.get(client, prop, receiver);\n      if (typeof prop !== \"string\") {\n        return value;\n      }\n      if (!isTypescriptObject(value)) {\n        return value;\n      }\n      return createSafeClient(value);\n    }\n  });\n  return proxy;\n}\n\nclass DynamicLink {\n  constructor(linkResolver) {\n    this.linkResolver = linkResolver;\n  }\n  async call(path, input, options) {\n    const resolvedLink = await this.linkResolver(options, path, input);\n    const output = await resolvedLink.call(path, input, options);\n    return output;\n  }\n}\n\nexport { DynamicLink, consumeEventIterator, createORPCClient, createSafeClient, isDefinedError, resolveFriendlyClientOptions, safe };\n","import { i as isContractProcedure, C as ContractProcedure, m as mergeErrorMap, V as ValidationError } from './shared/contract.D_dZrO__.mjs';\nexport { v as validateORPCError } from './shared/contract.D_dZrO__.mjs';\nimport { mapEventIterator, ORPCError } from '@orpc/client';\nexport { ORPCError } from '@orpc/client';\nimport { isAsyncIteratorObject, get, isTypescriptObject, isPropertyKey } from '@orpc/shared';\nexport { AsyncIteratorClass } from '@orpc/shared';\n\nfunction mergeMeta(meta1, meta2) {\n  return { ...meta1, ...meta2 };\n}\n\nfunction mergeRoute(a, b) {\n  return { ...a, ...b };\n}\nfunction prefixRoute(route, prefix) {\n  if (!route.path) {\n    return route;\n  }\n  return {\n    ...route,\n    path: `${prefix}${route.path}`\n  };\n}\nfunction unshiftTagRoute(route, tags) {\n  return {\n    ...route,\n    tags: [...tags, ...route.tags ?? []]\n  };\n}\nfunction mergePrefix(a, b) {\n  return a ? `${a}${b}` : b;\n}\nfunction mergeTags(a, b) {\n  return a ? [...a, ...b] : b;\n}\nfunction enhanceRoute(route, options) {\n  let router = route;\n  if (options.prefix) {\n    router = prefixRoute(router, options.prefix);\n  }\n  if (options.tags?.length) {\n    router = unshiftTagRoute(router, options.tags);\n  }\n  return router;\n}\n\nfunction getContractRouter(router, path) {\n  let current = router;\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n    if (!current) {\n      return void 0;\n    }\n    if (isContractProcedure(current)) {\n      return void 0;\n    }\n    current = current[segment];\n  }\n  return current;\n}\nfunction enhanceContractRouter(router, options) {\n  if (isContractProcedure(router)) {\n    const enhanced2 = new ContractProcedure({\n      ...router[\"~orpc\"],\n      errorMap: mergeErrorMap(options.errorMap, router[\"~orpc\"].errorMap),\n      route: enhanceRoute(router[\"~orpc\"].route, options)\n    });\n    return enhanced2;\n  }\n  const enhanced = {};\n  for (const key in router) {\n    enhanced[key] = enhanceContractRouter(router[key], options);\n  }\n  return enhanced;\n}\nfunction minifyContractRouter(router) {\n  if (isContractProcedure(router)) {\n    const procedure = {\n      \"~orpc\": {\n        errorMap: {},\n        meta: router[\"~orpc\"].meta,\n        route: router[\"~orpc\"].route\n      }\n    };\n    return procedure;\n  }\n  const json = {};\n  for (const key in router) {\n    json[key] = minifyContractRouter(router[key]);\n  }\n  return json;\n}\n\nclass ContractBuilder extends ContractProcedure {\n  constructor(def) {\n    super(def);\n    this[\"~orpc\"].prefix = def.prefix;\n    this[\"~orpc\"].tags = def.tags;\n  }\n  /**\n   * Sets or overrides the initial meta.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}\n   */\n  $meta(initialMeta) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      meta: initialMeta\n    });\n  }\n  /**\n   * Sets or overrides the initial route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  $route(initialRoute) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      route: initialRoute\n    });\n  }\n  /**\n   * Adds type-safe custom errors to the contract.\n   * The provided errors are spared-merged with any existing errors in the contract.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  /**\n   * Sets or updates the metadata for the contract.\n   * The provided metadata is spared-merged with any existing metadata in the contract.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition for the contract.\n   * The provided route is spared-merged with any existing route in the contract.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  /**\n   * Defines the input validation schema for the contract.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}\n   */\n  input(schema) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      inputSchema: schema\n    });\n  }\n  /**\n   * Defines the output validation schema for the contract.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}\n   */\n  output(schema) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      outputSchema: schema\n    });\n  }\n  /**\n   * Prefixes all procedures in the contract router.\n   * The provided prefix is post-appended to any existing router prefix.\n   *\n   * @note This option does not affect procedures that do not define a path in their route definition.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}\n   */\n  prefix(prefix) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      prefix: mergePrefix(this[\"~orpc\"].prefix, prefix)\n    });\n  }\n  /**\n   * Adds tags to all procedures in the contract router.\n   * This helpful when you want to group procedures together in the OpenAPI specification.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}\n   */\n  tag(...tags) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      tags: mergeTags(this[\"~orpc\"].tags, tags)\n    });\n  }\n  /**\n   * Applies all of the previously defined options to the specified contract router.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}\n   */\n  router(router) {\n    return enhanceContractRouter(router, this[\"~orpc\"]);\n  }\n}\nconst oc = new ContractBuilder({\n  errorMap: {},\n  route: {},\n  meta: {}\n});\n\nconst DEFAULT_CONFIG = {\n  defaultMethod: \"POST\",\n  defaultSuccessStatus: 200,\n  defaultSuccessDescription: \"OK\",\n  defaultInputStructure: \"compact\",\n  defaultOutputStructure: \"compact\"\n};\nfunction fallbackContractConfig(key, value) {\n  if (value === void 0) {\n    return DEFAULT_CONFIG[key];\n  }\n  return value;\n}\n\nconst EVENT_ITERATOR_DETAILS_SYMBOL = Symbol(\"ORPC_EVENT_ITERATOR_DETAILS\");\nfunction eventIterator(yields, returns) {\n  return {\n    \"~standard\": {\n      [EVENT_ITERATOR_DETAILS_SYMBOL]: { yields, returns },\n      vendor: \"orpc\",\n      version: 1,\n      validate(iterator) {\n        if (!isAsyncIteratorObject(iterator)) {\n          return { issues: [{ message: \"Expect event iterator\", path: [] }] };\n        }\n        const mapped = mapEventIterator(iterator, {\n          async value(value, done) {\n            const schema = done ? returns : yields;\n            if (!schema) {\n              return value;\n            }\n            const result = await schema[\"~standard\"].validate(value);\n            if (result.issues) {\n              throw new ORPCError(\"EVENT_ITERATOR_VALIDATION_FAILED\", {\n                message: \"Event iterator validation failed\",\n                cause: new ValidationError({\n                  issues: result.issues,\n                  message: \"Event iterator validation failed\",\n                  data: value\n                })\n              });\n            }\n            return result.value;\n          },\n          error: async (error) => error\n        });\n        return { value: mapped };\n      }\n    }\n  };\n}\nfunction getEventIteratorSchemaDetails(schema) {\n  if (schema === void 0) {\n    return void 0;\n  }\n  return schema[\"~standard\"][EVENT_ITERATOR_DETAILS_SYMBOL];\n}\n\nfunction inferRPCMethodFromContractRouter(contract) {\n  return (_, path) => {\n    const procedure = get(contract, path);\n    if (!isContractProcedure(procedure)) {\n      throw new Error(\n        `[inferRPCMethodFromContractRouter] No valid procedure found at path \"${path.join(\".\")}\". This may happen when the contract router is not properly configured.`\n      );\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    return method === \"HEAD\" ? \"GET\" : method;\n  };\n}\n\nfunction type(...[map]) {\n  return {\n    \"~standard\": {\n      vendor: \"custom\",\n      version: 1,\n      async validate(value) {\n        if (map) {\n          return { value: await map(value) };\n        }\n        return { value };\n      }\n    }\n  };\n}\n\nfunction isSchemaIssue(issue) {\n  if (!isTypescriptObject(issue) || typeof issue.message !== \"string\") {\n    return false;\n  }\n  if (issue.path !== void 0) {\n    if (!Array.isArray(issue.path)) {\n      return false;\n    }\n    if (!issue.path.every((segment) => isPropertyKey(segment) || isTypescriptObject(segment) && isPropertyKey(segment.key))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { ContractBuilder, ContractProcedure, ValidationError, enhanceContractRouter, enhanceRoute, eventIterator, fallbackContractConfig, getContractRouter, getEventIteratorSchemaDetails, inferRPCMethodFromContractRouter, isContractProcedure, isSchemaIssue, mergeErrorMap, mergeMeta, mergePrefix, mergeRoute, mergeTags, minifyContractRouter, oc, prefixRoute, type, unshiftTagRoute };\n","import { fallbackORPCErrorStatus, ORPCError, isORPCErrorStatus } from '@orpc/client';\n\nclass ValidationError extends Error {\n  issues;\n  data;\n  constructor(options) {\n    super(options.message, options);\n    this.issues = options.issues;\n    this.data = options.data;\n  }\n}\nfunction mergeErrorMap(errorMap1, errorMap2) {\n  return { ...errorMap1, ...errorMap2 };\n}\nasync function validateORPCError(map, error) {\n  const { code, status, message, data, cause, defined } = error;\n  const config = map?.[error.code];\n  if (!config || fallbackORPCErrorStatus(error.code, config.status) !== error.status) {\n    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;\n  }\n  if (!config.data) {\n    return defined ? error : new ORPCError(code, { defined: true, status, message, data, cause });\n  }\n  const validated = await config.data[\"~standard\"].validate(error.data);\n  if (validated.issues) {\n    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;\n  }\n  return new ORPCError(code, { defined: true, status, message, data: validated.value, cause });\n}\n\nclass ContractProcedure {\n  /**\n   * This property holds the defined options for the contract procedure.\n   */\n  \"~orpc\";\n  constructor(def) {\n    if (def.route?.successStatus && isORPCErrorStatus(def.route.successStatus)) {\n      throw new Error(\"[ContractProcedure] Invalid successStatus.\");\n    }\n    if (Object.values(def.errorMap).some((val) => val && val.status && !isORPCErrorStatus(val.status))) {\n      throw new Error(\"[ContractProcedure] Invalid error status code.\");\n    }\n    this[\"~orpc\"] = def;\n  }\n}\nfunction isContractProcedure(item) {\n  if (item instanceof ContractProcedure) {\n    return true;\n  }\n  return (typeof item === \"object\" || typeof item === \"function\") && item !== null && \"~orpc\" in item && typeof item[\"~orpc\"] === \"object\" && item[\"~orpc\"] !== null && \"errorMap\" in item[\"~orpc\"] && \"route\" in item[\"~orpc\"] && \"meta\" in item[\"~orpc\"];\n}\n\nexport { ContractProcedure as C, ValidationError as V, isContractProcedure as i, mergeErrorMap as m, validateORPCError as v };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}