"use strict";
exports.ids = ["vendors-node_modules_bun_orpc_server_1_10_4_node_modules_orpc_server_dist_index_mjs"];
exports.modules = {
"../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs": 
/*!********************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs ***!
  \********************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AsyncIteratorClass: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.AsyncIteratorClass),
  COMMON_ORPC_ERROR_DEFS: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.C),
  DynamicLink: () => (DynamicLink),
  ErrorEvent: () => (/* reexport safe */ _orpc_standard_server__WEBPACK_IMPORTED_MODULE_2__.ErrorEvent),
  EventPublisher: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.EventPublisher),
  ORPCError: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.c),
  ORPC_CLIENT_PACKAGE_NAME: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.O),
  ORPC_CLIENT_PACKAGE_VERSION: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.a),
  consumeEventIterator: () => (consumeEventIterator),
  createORPCClient: () => (createORPCClient),
  createORPCErrorFromJson: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.g),
  createSafeClient: () => (createSafeClient),
  eventIteratorToStream: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.asyncIteratorToStream),
  eventIteratorToUnproxiedDataStream: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.asyncIteratorToUnproxiedDataStream),
  fallbackORPCErrorMessage: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.b),
  fallbackORPCErrorStatus: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.f),
  isDefinedError: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.i),
  isORPCErrorJson: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.e),
  isORPCErrorStatus: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.d),
  mapEventIterator: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.m),
  onError: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.onError),
  onFinish: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.onFinish),
  onStart: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.onStart),
  onSuccess: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.onSuccess),
  resolveFriendlyClientOptions: () => (resolveFriendlyClientOptions),
  safe: () => (safe),
  streamToEventIterator: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.streamToAsyncIteratorClass),
  toORPCError: () => (/* reexport safe */ _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.t)
});
/* ESM import */var _orpc_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orpc/shared */ "../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs");
/* ESM import */var _shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/client.DmkMd_GB.mjs */ "../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/shared/client.DmkMd_GB.mjs");
/* ESM import */var _orpc_standard_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @orpc/standard-server */ "../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs");






async function safe(promise) {
  try {
    const output = await promise;
    return Object.assign(
      [null, output, false, true],
      { error: null, data: output, isDefined: false, isSuccess: true }
    );
  } catch (e) {
    const error = e;
    if ((0,_shared_client_DmkMd_GB_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(error)) {
      return Object.assign(
        [error, void 0, true, false],
        { error, data: void 0, isDefined: true, isSuccess: false }
      );
    }
    return Object.assign(
      [error, void 0, false, false],
      { error, data: void 0, isDefined: false, isSuccess: false }
    );
  }
}
function resolveFriendlyClientOptions(options) {
  return {
    ...options,
    context: options.context ?? {}
    // Context only optional if all fields are optional
  };
}
function consumeEventIterator(iterator, options) {
  void (async () => {
    let onFinishState;
    try {
      const resolvedIterator = await iterator;
      while (true) {
        const { done, value } = await resolvedIterator.next();
        if (done) {
          const realValue = value;
          onFinishState = [null, realValue, true];
          options.onSuccess?.(realValue);
          break;
        }
        options.onEvent(value);
      }
    } catch (error) {
      onFinishState = [error, void 0, false];
      if (!options.onError && !options.onFinish) {
        throw error;
      }
      options.onError?.(error);
    } finally {
      options.onFinish?.(onFinishState);
    }
  })();
  return async () => {
    await (await iterator)?.return?.();
  };
}

function createORPCClient(link, options = {}) {
  const path = options.path ?? [];
  const procedureClient = async (...[input, options2 = {}]) => {
    return await link.call(path, input, resolveFriendlyClientOptions(options2));
  };
  const recursive = new Proxy(procedureClient, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      return createORPCClient(link, {
        ...options,
        path: [...path, key]
      });
    }
  });
  return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.preventNativeAwait)(recursive);
}

function createSafeClient(client) {
  const proxy = new Proxy((...args) => safe(client(...args)), {
    get(_, prop, receiver) {
      const value = Reflect.get(client, prop, receiver);
      if (typeof prop !== "string") {
        return value;
      }
      if (!(0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isTypescriptObject)(value)) {
        return value;
      }
      return createSafeClient(value);
    }
  });
  return proxy;
}

class DynamicLink {
  constructor(linkResolver) {
    this.linkResolver = linkResolver;
  }
  async call(path, input, options) {
    const resolvedLink = await this.linkResolver(options, path, input);
    const output = await resolvedLink.call(path, input, options);
    return output;
  }
}




}),
"../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/index.mjs": 
/*!********************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/index.mjs ***!
  \********************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AsyncIteratorClass: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.AsyncIteratorClass),
  Builder: () => (Builder),
  DecoratedProcedure: () => (DecoratedProcedure),
  EventPublisher: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.EventPublisher),
  LAZY_SYMBOL: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.L),
  ORPCError: () => (/* reexport safe */ _orpc_client__WEBPACK_IMPORTED_MODULE_2__.ORPCError),
  Procedure: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.P),
  ValidationError: () => (/* reexport safe */ _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.ValidationError),
  addMiddleware: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.b),
  call: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.p),
  createAccessibleLazyRouter: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.r),
  createActionableClient: () => (createActionableClient),
  createAssertedLazyProcedure: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.f),
  createContractedProcedure: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.a),
  createORPCErrorConstructorMap: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.h),
  createProcedureClient: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.c),
  createRouterClient: () => (createRouterClient),
  decorateMiddleware: () => (decorateMiddleware),
  enhanceRouter: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.e),
  eventIterator: () => (/* reexport safe */ _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.eventIterator),
  eventIteratorToStream: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.asyncIteratorToStream),
  eventIteratorToUnproxiedDataStream: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.asyncIteratorToUnproxiedDataStream),
  fallbackConfig: () => (fallbackConfig),
  getEventMeta: () => (/* reexport safe */ _orpc_standard_server__WEBPACK_IMPORTED_MODULE_4__.getEventMeta),
  getHiddenRouterContract: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.q),
  getLazyMeta: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.j),
  getRouter: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.g),
  implement: () => (implement),
  implementerInternal: () => (implementerInternal),
  inferRPCMethodFromRouter: () => (inferRPCMethodFromRouter),
  isDefinedError: () => (/* reexport safe */ _orpc_client__WEBPACK_IMPORTED_MODULE_2__.isDefinedError),
  isLazy: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.d),
  isProcedure: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.i),
  isStartWithMiddlewares: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.n),
  lazy: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.l),
  mergeCurrentContext: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.m),
  mergeMiddlewares: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.o),
  middlewareOutputFn: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.k),
  onError: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.onError),
  onFinish: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.onFinish),
  onStart: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.onStart),
  onSuccess: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.onSuccess),
  os: () => (os),
  resolveContractProcedures: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.v),
  safe: () => (/* reexport safe */ _orpc_client__WEBPACK_IMPORTED_MODULE_2__.safe),
  setHiddenRouterContract: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.s),
  streamToEventIterator: () => (/* reexport safe */ _orpc_shared__WEBPACK_IMPORTED_MODULE_3__.streamToAsyncIteratorClass),
  traverseContractProcedures: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.t),
  type: () => (/* reexport safe */ _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.type),
  unlazy: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.u),
  unlazyRouter: () => (/* reexport safe */ _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.w),
  validateORPCError: () => (/* reexport safe */ _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.validateORPCError),
  withEventMeta: () => (/* reexport safe */ _orpc_standard_server__WEBPACK_IMPORTED_MODULE_4__.withEventMeta)
});
/* ESM import */var _orpc_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orpc/contract */ "webpack/sharing/consume/default/@orpc/contract/@orpc/contract");
/* ESM import */var _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/server.Ds4HPpvH.mjs */ "../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs");
/* ESM import */var _orpc_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @orpc/client */ "../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs");
/* ESM import */var _orpc_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @orpc/shared */ "../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs");
/* ESM import */var _orpc_standard_server__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @orpc/standard-server */ "../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs");










const DEFAULT_CONFIG = {
  initialInputValidationIndex: 0,
  initialOutputValidationIndex: 0,
  dedupeLeadingMiddlewares: true
};
function fallbackConfig(key, value) {
  if (value === void 0) {
    return DEFAULT_CONFIG[key];
  }
  return value;
}

function decorateMiddleware(middleware) {
  const decorated = ((...args) => middleware(...args));
  decorated.mapInput = (mapInput) => {
    const mapped = decorateMiddleware(
      (options, input, ...rest) => middleware(options, mapInput(input), ...rest)
    );
    return mapped;
  };
  decorated.concat = (concatMiddleware, mapInput) => {
    const mapped = mapInput ? decorateMiddleware(concatMiddleware).mapInput(mapInput) : concatMiddleware;
    const concatted = decorateMiddleware((options, input, output, ...rest) => {
      const merged = middleware({
        ...options,
        next: (...[nextOptions1]) => mapped({
          ...options,
          context: { ...options.context, ...nextOptions1?.context },
          next: (...[nextOptions2]) => options.next({ context: { ...nextOptions1?.context, ...nextOptions2?.context } })
        }, input, output, ...rest)
      }, input, output, ...rest);
      return merged;
    });
    return concatted;
  };
  return decorated;
}

function createActionableClient(client) {
  const action = async (input) => {
    try {
      return [null, await client(input)];
    } catch (error) {
      if (error instanceof Error && "digest" in error && typeof error.digest === "string" && error.digest.startsWith("NEXT_")) {
        throw error;
      }
      if (error instanceof Response && "options" in error && (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_3__.isObject)(error.options) || (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_3__.isObject)(error) && error.isNotFound === true) {
        throw error;
      }
      return [(0,_orpc_client__WEBPACK_IMPORTED_MODULE_2__.toORPCError)(error).toJSON(), void 0];
    }
  };
  return action;
}

class DecoratedProcedure extends _shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.P {
  /**
   * Adds type-safe custom errors.
   * The provided errors are spared-merged with any existing errors.
   *
   * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
   */
  errors(errors) {
    return new DecoratedProcedure({
      ...this["~orpc"],
      errorMap: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeErrorMap)(this["~orpc"].errorMap, errors)
    });
  }
  /**
   * Sets or updates the metadata.
   * The provided metadata is spared-merged with any existing metadata.
   *
   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
   */
  meta(meta) {
    return new DecoratedProcedure({
      ...this["~orpc"],
      meta: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeMeta)(this["~orpc"].meta, meta)
    });
  }
  /**
   * Sets or updates the route definition.
   * The provided route is spared-merged with any existing route.
   * This option is typically relevant when integrating with OpenAPI.
   *
   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
   */
  route(route) {
    return new DecoratedProcedure({
      ...this["~orpc"],
      route: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeRoute)(this["~orpc"].route, route)
    });
  }
  use(middleware, mapInput) {
    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
    return new DecoratedProcedure({
      ...this["~orpc"],
      middlewares: (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(this["~orpc"].middlewares, mapped)
    });
  }
  /**
   * Make this procedure callable (works like a function while still being a procedure).
   *
   * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
   */
  callable(...rest) {
    const client = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(this, ...rest);
    return new Proxy(client, {
      get: (target, key) => {
        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
      },
      has: (target, key) => {
        return Reflect.has(this, key) || Reflect.has(target, key);
      }
    });
  }
  /**
   * Make this procedure compatible with server action.
   *
   * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}
   */
  actionable(...rest) {
    const action = createActionableClient((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(this, ...rest));
    return new Proxy(action, {
      get: (target, key) => {
        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
      },
      has: (target, key) => {
        return Reflect.has(this, key) || Reflect.has(target, key);
      }
    });
  }
}

class Builder {
  /**
   * This property holds the defined options.
   */
  "~orpc";
  constructor(def) {
    this["~orpc"] = def;
  }
  /**
   * Sets or overrides the config.
   *
   * @see {@link https://orpc.unnoq.com/docs/client/server-side#middlewares-order Middlewares Order Docs}
   * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
   */
  $config(config) {
    const inputValidationCount = this["~orpc"].inputValidationIndex - fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex);
    const outputValidationCount = this["~orpc"].outputValidationIndex - fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex);
    return new Builder({
      ...this["~orpc"],
      config,
      dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config.dedupeLeadingMiddlewares),
      inputValidationIndex: fallbackConfig("initialInputValidationIndex", config.initialInputValidationIndex) + inputValidationCount,
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex", config.initialOutputValidationIndex) + outputValidationCount
    });
  }
  /**
   * Set or override the initial context.
   *
   * @see {@link https://orpc.unnoq.com/docs/context Context Docs}
   */
  $context() {
    return new Builder({
      ...this["~orpc"],
      middlewares: [],
      inputValidationIndex: fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex),
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex)
    });
  }
  /**
   * Sets or overrides the initial meta.
   *
   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
   */
  $meta(initialMeta) {
    return new Builder({
      ...this["~orpc"],
      meta: initialMeta
    });
  }
  /**
   * Sets or overrides the initial route.
   * This option is typically relevant when integrating with OpenAPI.
   *
   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
   */
  $route(initialRoute) {
    return new Builder({
      ...this["~orpc"],
      route: initialRoute
    });
  }
  /**
   * Sets or overrides the initial input schema.
   *
   * @see {@link https://orpc.unnoq.com/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
   */
  $input(initialInputSchema) {
    return new Builder({
      ...this["~orpc"],
      inputSchema: initialInputSchema
    });
  }
  /**
   * Creates a middleware.
   *
   * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
   */
  middleware(middleware) {
    return decorateMiddleware(middleware);
  }
  /**
   * Adds type-safe custom errors.
   * The provided errors are spared-merged with any existing errors.
   *
   * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
   */
  errors(errors) {
    return new Builder({
      ...this["~orpc"],
      errorMap: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeErrorMap)(this["~orpc"].errorMap, errors)
    });
  }
  use(middleware, mapInput) {
    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
    return new Builder({
      ...this["~orpc"],
      middlewares: (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(this["~orpc"].middlewares, mapped)
    });
  }
  /**
   * Sets or updates the metadata.
   * The provided metadata is spared-merged with any existing metadata.
   *
   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
   */
  meta(meta) {
    return new Builder({
      ...this["~orpc"],
      meta: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeMeta)(this["~orpc"].meta, meta)
    });
  }
  /**
   * Sets or updates the route definition.
   * The provided route is spared-merged with any existing route.
   * This option is typically relevant when integrating with OpenAPI.
   *
   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
   */
  route(route) {
    return new Builder({
      ...this["~orpc"],
      route: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeRoute)(this["~orpc"].route, route)
    });
  }
  /**
   * Defines the input validation schema.
   *
   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
   */
  input(schema) {
    return new Builder({
      ...this["~orpc"],
      inputSchema: schema,
      inputValidationIndex: fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex) + this["~orpc"].middlewares.length
    });
  }
  /**
   * Defines the output validation schema.
   *
   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
   */
  output(schema) {
    return new Builder({
      ...this["~orpc"],
      outputSchema: schema,
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex) + this["~orpc"].middlewares.length
    });
  }
  /**
   * Defines the handler of the procedure.
   *
   * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
   */
  handler(handler) {
    return new DecoratedProcedure({
      ...this["~orpc"],
      handler
    });
  }
  /**
   * Prefixes all procedures in the router.
   * The provided prefix is post-appended to any existing router prefix.
   *
   * @note This option does not affect procedures that do not define a path in their route definition.
   *
   * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
   */
  prefix(prefix) {
    return new Builder({
      ...this["~orpc"],
      prefix: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergePrefix)(this["~orpc"].prefix, prefix)
    });
  }
  /**
   * Adds tags to all procedures in the router.
   * This helpful when you want to group procedures together in the OpenAPI specification.
   *
   * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
   */
  tag(...tags) {
    return new Builder({
      ...this["~orpc"],
      tags: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeTags)(this["~orpc"].tags, tags)
    });
  }
  /**
   * Applies all of the previously defined options to the specified router.
   *
   * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
   */
  router(router) {
    return (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(router, this["~orpc"]);
  }
  /**
   * Create a lazy router
   * And applies all of the previously defined options to the specified router.
   *
   * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
   */
  lazy(loader) {
    return (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.e)((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(loader), this["~orpc"]);
  }
}
const os = new Builder({
  config: {},
  route: {},
  meta: {},
  errorMap: {},
  inputValidationIndex: fallbackConfig("initialInputValidationIndex"),
  outputValidationIndex: fallbackConfig("initialOutputValidationIndex"),
  middlewares: [],
  dedupeLeadingMiddlewares: true
});

function implementerInternal(contract, config, middlewares) {
  if ((0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.isContractProcedure)(contract)) {
    const impl2 = new Builder({
      ...contract["~orpc"],
      config,
      middlewares,
      inputValidationIndex: fallbackConfig("initialInputValidationIndex", config?.initialInputValidationIndex) + middlewares.length,
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex", config?.initialOutputValidationIndex) + middlewares.length,
      dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config.dedupeLeadingMiddlewares)
    });
    return impl2;
  }
  const impl = new Proxy(contract, {
    get: (target, key) => {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      let method;
      if (key === "middleware") {
        method = (mid) => decorateMiddleware(mid);
      } else if (key === "use") {
        method = (mid) => {
          return implementerInternal(
            contract,
            config,
            (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.b)(middlewares, mid)
          );
        };
      } else if (key === "router") {
        method = (router) => {
          const adapted = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(router, {
            middlewares,
            errorMap: {},
            prefix: void 0,
            tags: void 0,
            dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config.dedupeLeadingMiddlewares)
          });
          return (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(adapted, contract);
        };
      } else if (key === "lazy") {
        method = (loader) => {
          const adapted = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.e)((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(loader), {
            middlewares,
            errorMap: {},
            prefix: void 0,
            tags: void 0,
            dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config.dedupeLeadingMiddlewares)
          });
          return (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(adapted, contract);
        };
      }
      const next = (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.getContractRouter)(target, [key]);
      if (!next) {
        return method ?? next;
      }
      const nextImpl = implementerInternal(next, config, middlewares);
      if (method) {
        return new Proxy(method, {
          get(_, key2) {
            return Reflect.get(nextImpl, key2);
          }
        });
      }
      return nextImpl;
    }
  });
  return impl;
}
function implement(contract, config = {}) {
  const implInternal = implementerInternal(contract, config, []);
  const impl = new Proxy(implInternal, {
    get: (target, key) => {
      let method;
      if (key === "$context") {
        method = () => impl;
      } else if (key === "$config") {
        method = (config2) => implement(contract, config2);
      }
      const next = Reflect.get(target, key);
      if (!method || !next || typeof next !== "function" && typeof next !== "object") {
        return method || next;
      }
      return new Proxy(method, {
        get(_, key2) {
          return Reflect.get(next, key2);
        }
      });
    }
  });
  return impl;
}

function inferRPCMethodFromRouter(router) {
  return async (_, path) => {
    const { default: procedure } = await (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.u)((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(router, path));
    if (!(0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(procedure)) {
      throw new Error(
        `[inferRPCMethodFromRouter] No valid procedure found at path "${path.join(".")}". This may happen when the router is not properly configured.`
      );
    }
    const method = (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.fallbackContractConfig)("defaultMethod", procedure["~orpc"].route.method);
    return method === "HEAD" ? "GET" : method;
  };
}

function createRouterClient(router, ...rest) {
  const options = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_3__.resolveMaybeOptionalOptions)(rest);
  if ((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(router)) {
    const caller = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(router, options);
    return caller;
  }
  const procedureCaller = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.d)(router) ? (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.c)((0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(router), options) : {};
  const recursive = new Proxy(procedureCaller, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      const next = (0,_shared_server_Ds4HPpvH_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(router, [key]);
      if (!next) {
        return Reflect.get(target, key);
      }
      return createRouterClient(next, {
        ...rest[0],
        path: [...rest[0]?.path ?? [], key]
      });
    }
  });
  return recursive;
}




}),
"../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs": 
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs ***!
  \*************************************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  L: () => (LAZY_SYMBOL),
  P: () => (Procedure),
  a: () => (createContractedProcedure),
  b: () => (addMiddleware),
  c: () => (createProcedureClient),
  d: () => (isLazy),
  e: () => (enhanceRouter),
  f: () => (createAssertedLazyProcedure),
  g: () => (getRouter),
  h: () => (createORPCErrorConstructorMap),
  i: () => (isProcedure),
  j: () => (getLazyMeta),
  k: () => (middlewareOutputFn),
  l: () => (lazy),
  m: () => (mergeCurrentContext),
  n: () => (isStartWithMiddlewares),
  o: () => (mergeMiddlewares),
  p: () => (call),
  q: () => (getHiddenRouterContract),
  r: () => (createAccessibleLazyRouter),
  s: () => (setHiddenRouterContract),
  t: () => (traverseContractProcedures),
  u: () => (unlazy),
  v: () => (resolveContractProcedures),
  w: () => (unlazyRouter)
});
/* ESM import */var _orpc_contract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orpc/contract */ "webpack/sharing/consume/default/@orpc/contract/@orpc/contract");
/* ESM import */var _orpc_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @orpc/shared */ "../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs");
/* ESM import */var _orpc_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @orpc/client */ "../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs");
/* ESM import */var _orpc_standard_server__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @orpc/standard-server */ "../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs");





const LAZY_SYMBOL = Symbol("ORPC_LAZY_SYMBOL");
function lazy(loader, meta = {}) {
  return {
    [LAZY_SYMBOL]: {
      loader,
      meta
    }
  };
}
function isLazy(item) {
  return (typeof item === "object" || typeof item === "function") && item !== null && LAZY_SYMBOL in item;
}
function getLazyMeta(lazied) {
  return lazied[LAZY_SYMBOL].meta;
}
function unlazy(lazied) {
  return isLazy(lazied) ? lazied[LAZY_SYMBOL].loader() : Promise.resolve({ default: lazied });
}

function isStartWithMiddlewares(middlewares, compare) {
  if (compare.length > middlewares.length) {
    return false;
  }
  for (let i = 0; i < middlewares.length; i++) {
    if (compare[i] === void 0) {
      return true;
    }
    if (middlewares[i] !== compare[i]) {
      return false;
    }
  }
  return true;
}
function mergeMiddlewares(first, second, options) {
  if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {
    return second;
  }
  return [...first, ...second];
}
function addMiddleware(middlewares, addition) {
  return [...middlewares, addition];
}

class Procedure {
  /**
   * This property holds the defined options.
   */
  "~orpc";
  constructor(def) {
    this["~orpc"] = def;
  }
}
function isProcedure(item) {
  if (item instanceof Procedure) {
    return true;
  }
  return (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.isContractProcedure)(item) && "middlewares" in item["~orpc"] && "inputValidationIndex" in item["~orpc"] && "outputValidationIndex" in item["~orpc"] && "handler" in item["~orpc"];
}

function mergeCurrentContext(context, other) {
  return { ...context, ...other };
}

function createORPCErrorConstructorMap(errors) {
  const proxy = new Proxy(errors, {
    get(target, code) {
      if (typeof code !== "string") {
        return Reflect.get(target, code);
      }
      const item = (...rest) => {
        const options = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.resolveMaybeOptionalOptions)(rest);
        const config = errors[code];
        return new _orpc_client__WEBPACK_IMPORTED_MODULE_2__.ORPCError(code, {
          defined: Boolean(config),
          status: config?.status,
          message: options.message ?? config?.message,
          data: options.data,
          cause: options.cause
        });
      };
      return item;
    }
  });
  return proxy;
}

function middlewareOutputFn(output) {
  return { output, context: {} };
}

function createProcedureClient(lazyableProcedure, ...rest) {
  const options = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.resolveMaybeOptionalOptions)(rest);
  return async (...[input, callerOptions]) => {
    const path = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.toArray)(options.path);
    const { default: procedure } = await unlazy(lazyableProcedure);
    const clientContext = callerOptions?.context ?? {};
    const context = await (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.value)(options.context ?? {}, clientContext);
    const errors = createORPCErrorConstructorMap(procedure["~orpc"].errorMap);
    const validateError = async (e) => {
      if (e instanceof _orpc_client__WEBPACK_IMPORTED_MODULE_2__.ORPCError) {
        return await (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.validateORPCError)(procedure["~orpc"].errorMap, e);
      }
      return e;
    };
    try {
      const output = await (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.runWithSpan)(
        { name: "call_procedure", signal: callerOptions?.signal },
        (span) => {
          span?.setAttribute("procedure.path", [...path]);
          return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.intercept)(
            (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.toArray)(options.interceptors),
            {
              context,
              input,
              // input only optional when it undefinable so we can safely cast it
              errors,
              path,
              procedure,
              signal: callerOptions?.signal,
              lastEventId: callerOptions?.lastEventId
            },
            (interceptorOptions) => executeProcedureInternal(interceptorOptions.procedure, interceptorOptions)
          );
        }
      );
      if ((0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.isAsyncIteratorObject)(output)) {
        if (output instanceof _orpc_standard_server__WEBPACK_IMPORTED_MODULE_3__.HibernationEventIterator) {
          return output;
        }
        return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.overlayProxy)(output, (0,_orpc_client__WEBPACK_IMPORTED_MODULE_2__.mapEventIterator)(
          (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.asyncIteratorWithSpan)(
            { name: "consume_event_iterator_output", signal: callerOptions?.signal },
            output
          ),
          {
            value: (v) => v,
            error: (e) => validateError(e)
          }
        ));
      }
      return output;
    } catch (e) {
      throw await validateError(e);
    }
  };
}
async function validateInput(procedure, input) {
  const schema = procedure["~orpc"].inputSchema;
  if (!schema) {
    return input;
  }
  return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.runWithSpan)(
    { name: "validate_input" },
    async () => {
      const result = await schema["~standard"].validate(input);
      if (result.issues) {
        throw new _orpc_client__WEBPACK_IMPORTED_MODULE_2__.ORPCError("BAD_REQUEST", {
          message: "Input validation failed",
          data: {
            issues: result.issues
          },
          cause: new _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.ValidationError({
            message: "Input validation failed",
            issues: result.issues,
            data: input
          })
        });
      }
      return result.value;
    }
  );
}
async function validateOutput(procedure, output) {
  const schema = procedure["~orpc"].outputSchema;
  if (!schema) {
    return output;
  }
  return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.runWithSpan)(
    { name: "validate_output" },
    async () => {
      const result = await schema["~standard"].validate(output);
      if (result.issues) {
        throw new _orpc_client__WEBPACK_IMPORTED_MODULE_2__.ORPCError("INTERNAL_SERVER_ERROR", {
          message: "Output validation failed",
          cause: new _orpc_contract__WEBPACK_IMPORTED_MODULE_0__.ValidationError({
            message: "Output validation failed",
            issues: result.issues,
            data: output
          })
        });
      }
      return result.value;
    }
  );
}
async function executeProcedureInternal(procedure, options) {
  const middlewares = procedure["~orpc"].middlewares;
  const inputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].inputValidationIndex), middlewares.length);
  const outputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].outputValidationIndex), middlewares.length);
  const next = async (index, context, input) => {
    let currentInput = input;
    if (index === inputValidationIndex) {
      currentInput = await validateInput(procedure, currentInput);
    }
    const mid = middlewares[index];
    const output = mid ? await (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.runWithSpan)(
      { name: `middleware.${mid.name}`, signal: options.signal },
      async (span) => {
        span?.setAttribute("middleware.index", index);
        span?.setAttribute("middleware.name", mid.name);
        const result = await mid({
          ...options,
          context,
          next: async (...[nextOptions]) => {
            const nextContext = nextOptions?.context ?? {};
            return {
              output: await next(index + 1, mergeCurrentContext(context, nextContext), currentInput),
              context: nextContext
            };
          }
        }, currentInput, middlewareOutputFn);
        return result.output;
      }
    ) : await (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.runWithSpan)(
      { name: "handler", signal: options.signal },
      () => procedure["~orpc"].handler({ ...options, context, input: currentInput })
    );
    if (index === outputValidationIndex) {
      return await validateOutput(procedure, output);
    }
    return output;
  };
  return next(0, options.context, options.input);
}

const HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol("ORPC_HIDDEN_ROUTER_CONTRACT");
function setHiddenRouterContract(router, contract) {
  return new Proxy(router, {
    get(target, key) {
      if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {
        return contract;
      }
      return Reflect.get(target, key);
    }
  });
}
function getHiddenRouterContract(router) {
  return router[HIDDEN_ROUTER_CONTRACT_SYMBOL];
}

function getRouter(router, path) {
  let current = router;
  for (let i = 0; i < path.length; i++) {
    const segment = path[i];
    if (!current) {
      return void 0;
    }
    if (isProcedure(current)) {
      return void 0;
    }
    if (!isLazy(current)) {
      current = current[segment];
      continue;
    }
    const lazied = current;
    const rest = path.slice(i);
    return lazy(async () => {
      const unwrapped = await unlazy(lazied);
      const next = getRouter(unwrapped.default, rest);
      return unlazy(next);
    }, getLazyMeta(lazied));
  }
  return current;
}
function createAccessibleLazyRouter(lazied) {
  const recursive = new Proxy(lazied, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      const next = getRouter(lazied, [key]);
      return createAccessibleLazyRouter(next);
    }
  });
  return recursive;
}
function enhanceRouter(router, options) {
  if (isLazy(router)) {
    const laziedMeta = getLazyMeta(router);
    const enhancedPrefix = laziedMeta?.prefix ? (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergePrefix)(options.prefix, laziedMeta?.prefix) : options.prefix;
    const enhanced2 = lazy(async () => {
      const { default: unlaziedRouter } = await unlazy(router);
      const enhanced3 = enhanceRouter(unlaziedRouter, options);
      return unlazy(enhanced3);
    }, {
      ...laziedMeta,
      prefix: enhancedPrefix
    });
    const accessible = createAccessibleLazyRouter(enhanced2);
    return accessible;
  }
  if (isProcedure(router)) {
    const newMiddlewares = mergeMiddlewares(options.middlewares, router["~orpc"].middlewares, { dedupeLeading: options.dedupeLeadingMiddlewares });
    const newMiddlewareAdded = newMiddlewares.length - router["~orpc"].middlewares.length;
    const enhanced2 = new Procedure({
      ...router["~orpc"],
      route: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.enhanceRoute)(router["~orpc"].route, options),
      errorMap: (0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.mergeErrorMap)(options.errorMap, router["~orpc"].errorMap),
      middlewares: newMiddlewares,
      inputValidationIndex: router["~orpc"].inputValidationIndex + newMiddlewareAdded,
      outputValidationIndex: router["~orpc"].outputValidationIndex + newMiddlewareAdded
    });
    return enhanced2;
  }
  const enhanced = {};
  for (const key in router) {
    enhanced[key] = enhanceRouter(router[key], options);
  }
  return enhanced;
}
function traverseContractProcedures(options, callback, lazyOptions = []) {
  let currentRouter = options.router;
  const hiddenContract = getHiddenRouterContract(options.router);
  if (hiddenContract !== void 0) {
    currentRouter = hiddenContract;
  }
  if (isLazy(currentRouter)) {
    lazyOptions.push({
      router: currentRouter,
      path: options.path
    });
  } else if ((0,_orpc_contract__WEBPACK_IMPORTED_MODULE_0__.isContractProcedure)(currentRouter)) {
    callback({
      contract: currentRouter,
      path: options.path
    });
  } else {
    for (const key in currentRouter) {
      traverseContractProcedures(
        {
          router: currentRouter[key],
          path: [...options.path, key]
        },
        callback,
        lazyOptions
      );
    }
  }
  return lazyOptions;
}
async function resolveContractProcedures(options, callback) {
  const pending = [options];
  for (const options2 of pending) {
    const lazyOptions = traverseContractProcedures(options2, callback);
    for (const options3 of lazyOptions) {
      const { default: router } = await unlazy(options3.router);
      pending.push({
        router,
        path: options3.path
      });
    }
  }
}
async function unlazyRouter(router) {
  if (isProcedure(router)) {
    return router;
  }
  const unlazied = {};
  for (const key in router) {
    const item = router[key];
    const { default: unlaziedRouter } = await unlazy(item);
    unlazied[key] = await unlazyRouter(unlaziedRouter);
  }
  return unlazied;
}

function createAssertedLazyProcedure(lazied) {
  const lazyProcedure = lazy(async () => {
    const { default: maybeProcedure } = await unlazy(lazied);
    if (!isProcedure(maybeProcedure)) {
      throw new Error(`
            Expected a lazy<procedure> but got lazy<unknown>.
            This should be caught by TypeScript compilation.
            Please report this issue if this makes you feel uncomfortable.
        `);
    }
    return { default: maybeProcedure };
  }, getLazyMeta(lazied));
  return lazyProcedure;
}
function createContractedProcedure(procedure, contract) {
  return new Procedure({
    ...procedure["~orpc"],
    errorMap: contract["~orpc"].errorMap,
    route: contract["~orpc"].route,
    meta: contract["~orpc"].meta
  });
}
function call(procedure, input, ...rest) {
  const options = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_1__.resolveMaybeOptionalOptions)(rest);
  return createProcedureClient(procedure, options)(input, options);
}




}),

};
;
//# sourceMappingURL=vendors-node_modules_bun_orpc_server_1_10_4_node_modules_orpc_server_dist_index_mjs.js.map