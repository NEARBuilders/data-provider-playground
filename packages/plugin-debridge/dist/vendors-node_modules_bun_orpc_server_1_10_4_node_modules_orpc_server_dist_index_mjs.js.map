{"version":3,"file":"vendors-node_modules_bun_orpc_server_1_10_4_node_modules_orpc_server_dist_index_mjs.js","sources":["webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/index.mjs","webpack://near-intents_debridge-data-provider/../../node_modules/.bun/@orpc+server@1.10.4/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs"],"sourcesContent":["import { preventNativeAwait, isTypescriptObject } from '@orpc/shared';\nexport { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, asyncIteratorToUnproxiedDataStream as eventIteratorToUnproxiedDataStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';\nimport { i as isDefinedError } from './shared/client.DmkMd_GB.mjs';\nexport { C as COMMON_ORPC_ERROR_DEFS, c as ORPCError, O as ORPC_CLIENT_PACKAGE_NAME, a as ORPC_CLIENT_PACKAGE_VERSION, g as createORPCErrorFromJson, b as fallbackORPCErrorMessage, f as fallbackORPCErrorStatus, e as isORPCErrorJson, d as isORPCErrorStatus, m as mapEventIterator, t as toORPCError } from './shared/client.DmkMd_GB.mjs';\nexport { ErrorEvent } from '@orpc/standard-server';\n\nasync function safe(promise) {\n  try {\n    const output = await promise;\n    return Object.assign(\n      [null, output, false, true],\n      { error: null, data: output, isDefined: false, isSuccess: true }\n    );\n  } catch (e) {\n    const error = e;\n    if (isDefinedError(error)) {\n      return Object.assign(\n        [error, void 0, true, false],\n        { error, data: void 0, isDefined: true, isSuccess: false }\n      );\n    }\n    return Object.assign(\n      [error, void 0, false, false],\n      { error, data: void 0, isDefined: false, isSuccess: false }\n    );\n  }\n}\nfunction resolveFriendlyClientOptions(options) {\n  return {\n    ...options,\n    context: options.context ?? {}\n    // Context only optional if all fields are optional\n  };\n}\nfunction consumeEventIterator(iterator, options) {\n  void (async () => {\n    let onFinishState;\n    try {\n      const resolvedIterator = await iterator;\n      while (true) {\n        const { done, value } = await resolvedIterator.next();\n        if (done) {\n          const realValue = value;\n          onFinishState = [null, realValue, true];\n          options.onSuccess?.(realValue);\n          break;\n        }\n        options.onEvent(value);\n      }\n    } catch (error) {\n      onFinishState = [error, void 0, false];\n      if (!options.onError && !options.onFinish) {\n        throw error;\n      }\n      options.onError?.(error);\n    } finally {\n      options.onFinish?.(onFinishState);\n    }\n  })();\n  return async () => {\n    await (await iterator)?.return?.();\n  };\n}\n\nfunction createORPCClient(link, options = {}) {\n  const path = options.path ?? [];\n  const procedureClient = async (...[input, options2 = {}]) => {\n    return await link.call(path, input, resolveFriendlyClientOptions(options2));\n  };\n  const recursive = new Proxy(procedureClient, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      return createORPCClient(link, {\n        ...options,\n        path: [...path, key]\n      });\n    }\n  });\n  return preventNativeAwait(recursive);\n}\n\nfunction createSafeClient(client) {\n  const proxy = new Proxy((...args) => safe(client(...args)), {\n    get(_, prop, receiver) {\n      const value = Reflect.get(client, prop, receiver);\n      if (typeof prop !== \"string\") {\n        return value;\n      }\n      if (!isTypescriptObject(value)) {\n        return value;\n      }\n      return createSafeClient(value);\n    }\n  });\n  return proxy;\n}\n\nclass DynamicLink {\n  constructor(linkResolver) {\n    this.linkResolver = linkResolver;\n  }\n  async call(path, input, options) {\n    const resolvedLink = await this.linkResolver(options, path, input);\n    const output = await resolvedLink.call(path, input, options);\n    return output;\n  }\n}\n\nexport { DynamicLink, consumeEventIterator, createORPCClient, createSafeClient, isDefinedError, resolveFriendlyClientOptions, safe };\n","import { mergeErrorMap, mergeMeta, mergeRoute, mergePrefix, mergeTags, isContractProcedure, getContractRouter, fallbackContractConfig } from '@orpc/contract';\nexport { ValidationError, eventIterator, type, validateORPCError } from '@orpc/contract';\nimport { P as Procedure, b as addMiddleware, c as createProcedureClient, e as enhanceRouter, l as lazy, s as setHiddenRouterContract, u as unlazy, g as getRouter, i as isProcedure, d as isLazy, f as createAssertedLazyProcedure } from './shared/server.Ds4HPpvH.mjs';\nexport { L as LAZY_SYMBOL, p as call, r as createAccessibleLazyRouter, a as createContractedProcedure, h as createORPCErrorConstructorMap, q as getHiddenRouterContract, j as getLazyMeta, n as isStartWithMiddlewares, m as mergeCurrentContext, o as mergeMiddlewares, k as middlewareOutputFn, v as resolveContractProcedures, t as traverseContractProcedures, w as unlazyRouter } from './shared/server.Ds4HPpvH.mjs';\nimport { toORPCError } from '@orpc/client';\nexport { ORPCError, isDefinedError, safe } from '@orpc/client';\nimport { isObject, resolveMaybeOptionalOptions } from '@orpc/shared';\nexport { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, asyncIteratorToUnproxiedDataStream as eventIteratorToUnproxiedDataStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';\nexport { getEventMeta, withEventMeta } from '@orpc/standard-server';\n\nconst DEFAULT_CONFIG = {\n  initialInputValidationIndex: 0,\n  initialOutputValidationIndex: 0,\n  dedupeLeadingMiddlewares: true\n};\nfunction fallbackConfig(key, value) {\n  if (value === void 0) {\n    return DEFAULT_CONFIG[key];\n  }\n  return value;\n}\n\nfunction decorateMiddleware(middleware) {\n  const decorated = ((...args) => middleware(...args));\n  decorated.mapInput = (mapInput) => {\n    const mapped = decorateMiddleware(\n      (options, input, ...rest) => middleware(options, mapInput(input), ...rest)\n    );\n    return mapped;\n  };\n  decorated.concat = (concatMiddleware, mapInput) => {\n    const mapped = mapInput ? decorateMiddleware(concatMiddleware).mapInput(mapInput) : concatMiddleware;\n    const concatted = decorateMiddleware((options, input, output, ...rest) => {\n      const merged = middleware({\n        ...options,\n        next: (...[nextOptions1]) => mapped({\n          ...options,\n          context: { ...options.context, ...nextOptions1?.context },\n          next: (...[nextOptions2]) => options.next({ context: { ...nextOptions1?.context, ...nextOptions2?.context } })\n        }, input, output, ...rest)\n      }, input, output, ...rest);\n      return merged;\n    });\n    return concatted;\n  };\n  return decorated;\n}\n\nfunction createActionableClient(client) {\n  const action = async (input) => {\n    try {\n      return [null, await client(input)];\n    } catch (error) {\n      if (error instanceof Error && \"digest\" in error && typeof error.digest === \"string\" && error.digest.startsWith(\"NEXT_\")) {\n        throw error;\n      }\n      if (error instanceof Response && \"options\" in error && isObject(error.options) || isObject(error) && error.isNotFound === true) {\n        throw error;\n      }\n      return [toORPCError(error).toJSON(), void 0];\n    }\n  };\n  return action;\n}\n\nclass DecoratedProcedure extends Procedure {\n  /**\n   * Adds type-safe custom errors.\n   * The provided errors are spared-merged with any existing errors.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  /**\n   * Sets or updates the metadata.\n   * The provided metadata is spared-merged with any existing metadata.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition.\n   * The provided route is spared-merged with any existing route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  use(middleware, mapInput) {\n    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      middlewares: addMiddleware(this[\"~orpc\"].middlewares, mapped)\n    });\n  }\n  /**\n   * Make this procedure callable (works like a function while still being a procedure).\n   *\n   * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}\n   */\n  callable(...rest) {\n    const client = createProcedureClient(this, ...rest);\n    return new Proxy(client, {\n      get: (target, key) => {\n        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);\n      },\n      has: (target, key) => {\n        return Reflect.has(this, key) || Reflect.has(target, key);\n      }\n    });\n  }\n  /**\n   * Make this procedure compatible with server action.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}\n   */\n  actionable(...rest) {\n    const action = createActionableClient(createProcedureClient(this, ...rest));\n    return new Proxy(action, {\n      get: (target, key) => {\n        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);\n      },\n      has: (target, key) => {\n        return Reflect.has(this, key) || Reflect.has(target, key);\n      }\n    });\n  }\n}\n\nclass Builder {\n  /**\n   * This property holds the defined options.\n   */\n  \"~orpc\";\n  constructor(def) {\n    this[\"~orpc\"] = def;\n  }\n  /**\n   * Sets or overrides the config.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/client/server-side#middlewares-order Middlewares Order Docs}\n   * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}\n   */\n  $config(config) {\n    const inputValidationCount = this[\"~orpc\"].inputValidationIndex - fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex);\n    const outputValidationCount = this[\"~orpc\"].outputValidationIndex - fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex);\n    return new Builder({\n      ...this[\"~orpc\"],\n      config,\n      dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares),\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", config.initialInputValidationIndex) + inputValidationCount,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", config.initialOutputValidationIndex) + outputValidationCount\n    });\n  }\n  /**\n   * Set or override the initial context.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/context Context Docs}\n   */\n  $context() {\n    return new Builder({\n      ...this[\"~orpc\"],\n      middlewares: [],\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex),\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex)\n    });\n  }\n  /**\n   * Sets or overrides the initial meta.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}\n   */\n  $meta(initialMeta) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      meta: initialMeta\n    });\n  }\n  /**\n   * Sets or overrides the initial route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  $route(initialRoute) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      route: initialRoute\n    });\n  }\n  /**\n   * Sets or overrides the initial input schema.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure#initial-configuration Initial Procedure Configuration Docs}\n   */\n  $input(initialInputSchema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      inputSchema: initialInputSchema\n    });\n  }\n  /**\n   * Creates a middleware.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}\n   */\n  middleware(middleware) {\n    return decorateMiddleware(middleware);\n  }\n  /**\n   * Adds type-safe custom errors.\n   * The provided errors are spared-merged with any existing errors.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  use(middleware, mapInput) {\n    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;\n    return new Builder({\n      ...this[\"~orpc\"],\n      middlewares: addMiddleware(this[\"~orpc\"].middlewares, mapped)\n    });\n  }\n  /**\n   * Sets or updates the metadata.\n   * The provided metadata is spared-merged with any existing metadata.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition.\n   * The provided route is spared-merged with any existing route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  /**\n   * Defines the input validation schema.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}\n   */\n  input(schema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      inputSchema: schema,\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex) + this[\"~orpc\"].middlewares.length\n    });\n  }\n  /**\n   * Defines the output validation schema.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}\n   */\n  output(schema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      outputSchema: schema,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex) + this[\"~orpc\"].middlewares.length\n    });\n  }\n  /**\n   * Defines the handler of the procedure.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}\n   */\n  handler(handler) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      handler\n    });\n  }\n  /**\n   * Prefixes all procedures in the router.\n   * The provided prefix is post-appended to any existing router prefix.\n   *\n   * @note This option does not affect procedures that do not define a path in their route definition.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}\n   */\n  prefix(prefix) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      prefix: mergePrefix(this[\"~orpc\"].prefix, prefix)\n    });\n  }\n  /**\n   * Adds tags to all procedures in the router.\n   * This helpful when you want to group procedures together in the OpenAPI specification.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}\n   */\n  tag(...tags) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      tags: mergeTags(this[\"~orpc\"].tags, tags)\n    });\n  }\n  /**\n   * Applies all of the previously defined options to the specified router.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}\n   */\n  router(router) {\n    return enhanceRouter(router, this[\"~orpc\"]);\n  }\n  /**\n   * Create a lazy router\n   * And applies all of the previously defined options to the specified router.\n   *\n   * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}\n   */\n  lazy(loader) {\n    return enhanceRouter(lazy(loader), this[\"~orpc\"]);\n  }\n}\nconst os = new Builder({\n  config: {},\n  route: {},\n  meta: {},\n  errorMap: {},\n  inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\"),\n  outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\"),\n  middlewares: [],\n  dedupeLeadingMiddlewares: true\n});\n\nfunction implementerInternal(contract, config, middlewares) {\n  if (isContractProcedure(contract)) {\n    const impl2 = new Builder({\n      ...contract[\"~orpc\"],\n      config,\n      middlewares,\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", config?.initialInputValidationIndex) + middlewares.length,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", config?.initialOutputValidationIndex) + middlewares.length,\n      dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n    });\n    return impl2;\n  }\n  const impl = new Proxy(contract, {\n    get: (target, key) => {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      let method;\n      if (key === \"middleware\") {\n        method = (mid) => decorateMiddleware(mid);\n      } else if (key === \"use\") {\n        method = (mid) => {\n          return implementerInternal(\n            contract,\n            config,\n            addMiddleware(middlewares, mid)\n          );\n        };\n      } else if (key === \"router\") {\n        method = (router) => {\n          const adapted = enhanceRouter(router, {\n            middlewares,\n            errorMap: {},\n            prefix: void 0,\n            tags: void 0,\n            dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n          });\n          return setHiddenRouterContract(adapted, contract);\n        };\n      } else if (key === \"lazy\") {\n        method = (loader) => {\n          const adapted = enhanceRouter(lazy(loader), {\n            middlewares,\n            errorMap: {},\n            prefix: void 0,\n            tags: void 0,\n            dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n          });\n          return setHiddenRouterContract(adapted, contract);\n        };\n      }\n      const next = getContractRouter(target, [key]);\n      if (!next) {\n        return method ?? next;\n      }\n      const nextImpl = implementerInternal(next, config, middlewares);\n      if (method) {\n        return new Proxy(method, {\n          get(_, key2) {\n            return Reflect.get(nextImpl, key2);\n          }\n        });\n      }\n      return nextImpl;\n    }\n  });\n  return impl;\n}\nfunction implement(contract, config = {}) {\n  const implInternal = implementerInternal(contract, config, []);\n  const impl = new Proxy(implInternal, {\n    get: (target, key) => {\n      let method;\n      if (key === \"$context\") {\n        method = () => impl;\n      } else if (key === \"$config\") {\n        method = (config2) => implement(contract, config2);\n      }\n      const next = Reflect.get(target, key);\n      if (!method || !next || typeof next !== \"function\" && typeof next !== \"object\") {\n        return method || next;\n      }\n      return new Proxy(method, {\n        get(_, key2) {\n          return Reflect.get(next, key2);\n        }\n      });\n    }\n  });\n  return impl;\n}\n\nfunction inferRPCMethodFromRouter(router) {\n  return async (_, path) => {\n    const { default: procedure } = await unlazy(getRouter(router, path));\n    if (!isProcedure(procedure)) {\n      throw new Error(\n        `[inferRPCMethodFromRouter] No valid procedure found at path \"${path.join(\".\")}\". This may happen when the router is not properly configured.`\n      );\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    return method === \"HEAD\" ? \"GET\" : method;\n  };\n}\n\nfunction createRouterClient(router, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  if (isProcedure(router)) {\n    const caller = createProcedureClient(router, options);\n    return caller;\n  }\n  const procedureCaller = isLazy(router) ? createProcedureClient(createAssertedLazyProcedure(router), options) : {};\n  const recursive = new Proxy(procedureCaller, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      const next = getRouter(router, [key]);\n      if (!next) {\n        return Reflect.get(target, key);\n      }\n      return createRouterClient(next, {\n        ...rest[0],\n        path: [...rest[0]?.path ?? [], key]\n      });\n    }\n  });\n  return recursive;\n}\n\nexport { Builder, DecoratedProcedure, Procedure, addMiddleware, createActionableClient, createAssertedLazyProcedure, createProcedureClient, createRouterClient, decorateMiddleware, enhanceRouter, fallbackConfig, getRouter, implement, implementerInternal, inferRPCMethodFromRouter, isLazy, isProcedure, lazy, os, setHiddenRouterContract, unlazy };\n","import { isContractProcedure, validateORPCError, ValidationError, mergePrefix, mergeErrorMap, enhanceRoute } from '@orpc/contract';\nimport { resolveMaybeOptionalOptions, toArray, value, runWithSpan, intercept, isAsyncIteratorObject, overlayProxy, asyncIteratorWithSpan } from '@orpc/shared';\nimport { ORPCError, mapEventIterator } from '@orpc/client';\nimport { HibernationEventIterator } from '@orpc/standard-server';\n\nconst LAZY_SYMBOL = Symbol(\"ORPC_LAZY_SYMBOL\");\nfunction lazy(loader, meta = {}) {\n  return {\n    [LAZY_SYMBOL]: {\n      loader,\n      meta\n    }\n  };\n}\nfunction isLazy(item) {\n  return (typeof item === \"object\" || typeof item === \"function\") && item !== null && LAZY_SYMBOL in item;\n}\nfunction getLazyMeta(lazied) {\n  return lazied[LAZY_SYMBOL].meta;\n}\nfunction unlazy(lazied) {\n  return isLazy(lazied) ? lazied[LAZY_SYMBOL].loader() : Promise.resolve({ default: lazied });\n}\n\nfunction isStartWithMiddlewares(middlewares, compare) {\n  if (compare.length > middlewares.length) {\n    return false;\n  }\n  for (let i = 0; i < middlewares.length; i++) {\n    if (compare[i] === void 0) {\n      return true;\n    }\n    if (middlewares[i] !== compare[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mergeMiddlewares(first, second, options) {\n  if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {\n    return second;\n  }\n  return [...first, ...second];\n}\nfunction addMiddleware(middlewares, addition) {\n  return [...middlewares, addition];\n}\n\nclass Procedure {\n  /**\n   * This property holds the defined options.\n   */\n  \"~orpc\";\n  constructor(def) {\n    this[\"~orpc\"] = def;\n  }\n}\nfunction isProcedure(item) {\n  if (item instanceof Procedure) {\n    return true;\n  }\n  return isContractProcedure(item) && \"middlewares\" in item[\"~orpc\"] && \"inputValidationIndex\" in item[\"~orpc\"] && \"outputValidationIndex\" in item[\"~orpc\"] && \"handler\" in item[\"~orpc\"];\n}\n\nfunction mergeCurrentContext(context, other) {\n  return { ...context, ...other };\n}\n\nfunction createORPCErrorConstructorMap(errors) {\n  const proxy = new Proxy(errors, {\n    get(target, code) {\n      if (typeof code !== \"string\") {\n        return Reflect.get(target, code);\n      }\n      const item = (...rest) => {\n        const options = resolveMaybeOptionalOptions(rest);\n        const config = errors[code];\n        return new ORPCError(code, {\n          defined: Boolean(config),\n          status: config?.status,\n          message: options.message ?? config?.message,\n          data: options.data,\n          cause: options.cause\n        });\n      };\n      return item;\n    }\n  });\n  return proxy;\n}\n\nfunction middlewareOutputFn(output) {\n  return { output, context: {} };\n}\n\nfunction createProcedureClient(lazyableProcedure, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  return async (...[input, callerOptions]) => {\n    const path = toArray(options.path);\n    const { default: procedure } = await unlazy(lazyableProcedure);\n    const clientContext = callerOptions?.context ?? {};\n    const context = await value(options.context ?? {}, clientContext);\n    const errors = createORPCErrorConstructorMap(procedure[\"~orpc\"].errorMap);\n    const validateError = async (e) => {\n      if (e instanceof ORPCError) {\n        return await validateORPCError(procedure[\"~orpc\"].errorMap, e);\n      }\n      return e;\n    };\n    try {\n      const output = await runWithSpan(\n        { name: \"call_procedure\", signal: callerOptions?.signal },\n        (span) => {\n          span?.setAttribute(\"procedure.path\", [...path]);\n          return intercept(\n            toArray(options.interceptors),\n            {\n              context,\n              input,\n              // input only optional when it undefinable so we can safely cast it\n              errors,\n              path,\n              procedure,\n              signal: callerOptions?.signal,\n              lastEventId: callerOptions?.lastEventId\n            },\n            (interceptorOptions) => executeProcedureInternal(interceptorOptions.procedure, interceptorOptions)\n          );\n        }\n      );\n      if (isAsyncIteratorObject(output)) {\n        if (output instanceof HibernationEventIterator) {\n          return output;\n        }\n        return overlayProxy(output, mapEventIterator(\n          asyncIteratorWithSpan(\n            { name: \"consume_event_iterator_output\", signal: callerOptions?.signal },\n            output\n          ),\n          {\n            value: (v) => v,\n            error: (e) => validateError(e)\n          }\n        ));\n      }\n      return output;\n    } catch (e) {\n      throw await validateError(e);\n    }\n  };\n}\nasync function validateInput(procedure, input) {\n  const schema = procedure[\"~orpc\"].inputSchema;\n  if (!schema) {\n    return input;\n  }\n  return runWithSpan(\n    { name: \"validate_input\" },\n    async () => {\n      const result = await schema[\"~standard\"].validate(input);\n      if (result.issues) {\n        throw new ORPCError(\"BAD_REQUEST\", {\n          message: \"Input validation failed\",\n          data: {\n            issues: result.issues\n          },\n          cause: new ValidationError({\n            message: \"Input validation failed\",\n            issues: result.issues,\n            data: input\n          })\n        });\n      }\n      return result.value;\n    }\n  );\n}\nasync function validateOutput(procedure, output) {\n  const schema = procedure[\"~orpc\"].outputSchema;\n  if (!schema) {\n    return output;\n  }\n  return runWithSpan(\n    { name: \"validate_output\" },\n    async () => {\n      const result = await schema[\"~standard\"].validate(output);\n      if (result.issues) {\n        throw new ORPCError(\"INTERNAL_SERVER_ERROR\", {\n          message: \"Output validation failed\",\n          cause: new ValidationError({\n            message: \"Output validation failed\",\n            issues: result.issues,\n            data: output\n          })\n        });\n      }\n      return result.value;\n    }\n  );\n}\nasync function executeProcedureInternal(procedure, options) {\n  const middlewares = procedure[\"~orpc\"].middlewares;\n  const inputValidationIndex = Math.min(Math.max(0, procedure[\"~orpc\"].inputValidationIndex), middlewares.length);\n  const outputValidationIndex = Math.min(Math.max(0, procedure[\"~orpc\"].outputValidationIndex), middlewares.length);\n  const next = async (index, context, input) => {\n    let currentInput = input;\n    if (index === inputValidationIndex) {\n      currentInput = await validateInput(procedure, currentInput);\n    }\n    const mid = middlewares[index];\n    const output = mid ? await runWithSpan(\n      { name: `middleware.${mid.name}`, signal: options.signal },\n      async (span) => {\n        span?.setAttribute(\"middleware.index\", index);\n        span?.setAttribute(\"middleware.name\", mid.name);\n        const result = await mid({\n          ...options,\n          context,\n          next: async (...[nextOptions]) => {\n            const nextContext = nextOptions?.context ?? {};\n            return {\n              output: await next(index + 1, mergeCurrentContext(context, nextContext), currentInput),\n              context: nextContext\n            };\n          }\n        }, currentInput, middlewareOutputFn);\n        return result.output;\n      }\n    ) : await runWithSpan(\n      { name: \"handler\", signal: options.signal },\n      () => procedure[\"~orpc\"].handler({ ...options, context, input: currentInput })\n    );\n    if (index === outputValidationIndex) {\n      return await validateOutput(procedure, output);\n    }\n    return output;\n  };\n  return next(0, options.context, options.input);\n}\n\nconst HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol(\"ORPC_HIDDEN_ROUTER_CONTRACT\");\nfunction setHiddenRouterContract(router, contract) {\n  return new Proxy(router, {\n    get(target, key) {\n      if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {\n        return contract;\n      }\n      return Reflect.get(target, key);\n    }\n  });\n}\nfunction getHiddenRouterContract(router) {\n  return router[HIDDEN_ROUTER_CONTRACT_SYMBOL];\n}\n\nfunction getRouter(router, path) {\n  let current = router;\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n    if (!current) {\n      return void 0;\n    }\n    if (isProcedure(current)) {\n      return void 0;\n    }\n    if (!isLazy(current)) {\n      current = current[segment];\n      continue;\n    }\n    const lazied = current;\n    const rest = path.slice(i);\n    return lazy(async () => {\n      const unwrapped = await unlazy(lazied);\n      const next = getRouter(unwrapped.default, rest);\n      return unlazy(next);\n    }, getLazyMeta(lazied));\n  }\n  return current;\n}\nfunction createAccessibleLazyRouter(lazied) {\n  const recursive = new Proxy(lazied, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      const next = getRouter(lazied, [key]);\n      return createAccessibleLazyRouter(next);\n    }\n  });\n  return recursive;\n}\nfunction enhanceRouter(router, options) {\n  if (isLazy(router)) {\n    const laziedMeta = getLazyMeta(router);\n    const enhancedPrefix = laziedMeta?.prefix ? mergePrefix(options.prefix, laziedMeta?.prefix) : options.prefix;\n    const enhanced2 = lazy(async () => {\n      const { default: unlaziedRouter } = await unlazy(router);\n      const enhanced3 = enhanceRouter(unlaziedRouter, options);\n      return unlazy(enhanced3);\n    }, {\n      ...laziedMeta,\n      prefix: enhancedPrefix\n    });\n    const accessible = createAccessibleLazyRouter(enhanced2);\n    return accessible;\n  }\n  if (isProcedure(router)) {\n    const newMiddlewares = mergeMiddlewares(options.middlewares, router[\"~orpc\"].middlewares, { dedupeLeading: options.dedupeLeadingMiddlewares });\n    const newMiddlewareAdded = newMiddlewares.length - router[\"~orpc\"].middlewares.length;\n    const enhanced2 = new Procedure({\n      ...router[\"~orpc\"],\n      route: enhanceRoute(router[\"~orpc\"].route, options),\n      errorMap: mergeErrorMap(options.errorMap, router[\"~orpc\"].errorMap),\n      middlewares: newMiddlewares,\n      inputValidationIndex: router[\"~orpc\"].inputValidationIndex + newMiddlewareAdded,\n      outputValidationIndex: router[\"~orpc\"].outputValidationIndex + newMiddlewareAdded\n    });\n    return enhanced2;\n  }\n  const enhanced = {};\n  for (const key in router) {\n    enhanced[key] = enhanceRouter(router[key], options);\n  }\n  return enhanced;\n}\nfunction traverseContractProcedures(options, callback, lazyOptions = []) {\n  let currentRouter = options.router;\n  const hiddenContract = getHiddenRouterContract(options.router);\n  if (hiddenContract !== void 0) {\n    currentRouter = hiddenContract;\n  }\n  if (isLazy(currentRouter)) {\n    lazyOptions.push({\n      router: currentRouter,\n      path: options.path\n    });\n  } else if (isContractProcedure(currentRouter)) {\n    callback({\n      contract: currentRouter,\n      path: options.path\n    });\n  } else {\n    for (const key in currentRouter) {\n      traverseContractProcedures(\n        {\n          router: currentRouter[key],\n          path: [...options.path, key]\n        },\n        callback,\n        lazyOptions\n      );\n    }\n  }\n  return lazyOptions;\n}\nasync function resolveContractProcedures(options, callback) {\n  const pending = [options];\n  for (const options2 of pending) {\n    const lazyOptions = traverseContractProcedures(options2, callback);\n    for (const options3 of lazyOptions) {\n      const { default: router } = await unlazy(options3.router);\n      pending.push({\n        router,\n        path: options3.path\n      });\n    }\n  }\n}\nasync function unlazyRouter(router) {\n  if (isProcedure(router)) {\n    return router;\n  }\n  const unlazied = {};\n  for (const key in router) {\n    const item = router[key];\n    const { default: unlaziedRouter } = await unlazy(item);\n    unlazied[key] = await unlazyRouter(unlaziedRouter);\n  }\n  return unlazied;\n}\n\nfunction createAssertedLazyProcedure(lazied) {\n  const lazyProcedure = lazy(async () => {\n    const { default: maybeProcedure } = await unlazy(lazied);\n    if (!isProcedure(maybeProcedure)) {\n      throw new Error(`\n            Expected a lazy<procedure> but got lazy<unknown>.\n            This should be caught by TypeScript compilation.\n            Please report this issue if this makes you feel uncomfortable.\n        `);\n    }\n    return { default: maybeProcedure };\n  }, getLazyMeta(lazied));\n  return lazyProcedure;\n}\nfunction createContractedProcedure(procedure, contract) {\n  return new Procedure({\n    ...procedure[\"~orpc\"],\n    errorMap: contract[\"~orpc\"].errorMap,\n    route: contract[\"~orpc\"].route,\n    meta: contract[\"~orpc\"].meta\n  });\n}\nfunction call(procedure, input, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  return createProcedureClient(procedure, options)(input, options);\n}\n\nexport { LAZY_SYMBOL as L, Procedure as P, createContractedProcedure as a, addMiddleware as b, createProcedureClient as c, isLazy as d, enhanceRouter as e, createAssertedLazyProcedure as f, getRouter as g, createORPCErrorConstructorMap as h, isProcedure as i, getLazyMeta as j, middlewareOutputFn as k, lazy as l, mergeCurrentContext as m, isStartWithMiddlewares as n, mergeMiddlewares as o, call as p, getHiddenRouterContract as q, createAccessibleLazyRouter as r, setHiddenRouterContract as s, traverseContractProcedures as t, unlazy as u, resolveContractProcedures as v, unlazyRouter as w };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}