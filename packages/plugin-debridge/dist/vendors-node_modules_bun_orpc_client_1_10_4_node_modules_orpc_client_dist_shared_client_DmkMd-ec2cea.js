"use strict";
exports.ids = ["vendors-node_modules_bun_orpc_client_1_10_4_node_modules_orpc_client_dist_shared_client_DmkMd-ec2cea"];
exports.modules = {
"../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/shared/client.DmkMd_GB.mjs": 
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+client@1.10.4/node_modules/@orpc/client/dist/shared/client.DmkMd_GB.mjs ***!
  \*************************************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  C: () => (COMMON_ORPC_ERROR_DEFS),
  O: () => (ORPC_CLIENT_PACKAGE_NAME),
  a: () => (ORPC_CLIENT_PACKAGE_VERSION),
  b: () => (fallbackORPCErrorMessage),
  c: () => (ORPCError),
  d: () => (isORPCErrorStatus),
  e: () => (isORPCErrorJson),
  f: () => (fallbackORPCErrorStatus),
  g: () => (createORPCErrorFromJson),
  i: () => (isDefinedError),
  m: () => (mapEventIterator),
  t: () => (toORPCError)
});
/* ESM import */var _orpc_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orpc/shared */ "../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs");
/* ESM import */var _orpc_standard_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @orpc/standard-server */ "../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs");



const ORPC_CLIENT_PACKAGE_NAME = "@orpc/client";
const ORPC_CLIENT_PACKAGE_VERSION = "1.10.4";

const COMMON_ORPC_ERROR_DEFS = {
  BAD_REQUEST: {
    status: 400,
    message: "Bad Request"
  },
  UNAUTHORIZED: {
    status: 401,
    message: "Unauthorized"
  },
  FORBIDDEN: {
    status: 403,
    message: "Forbidden"
  },
  NOT_FOUND: {
    status: 404,
    message: "Not Found"
  },
  METHOD_NOT_SUPPORTED: {
    status: 405,
    message: "Method Not Supported"
  },
  NOT_ACCEPTABLE: {
    status: 406,
    message: "Not Acceptable"
  },
  TIMEOUT: {
    status: 408,
    message: "Request Timeout"
  },
  CONFLICT: {
    status: 409,
    message: "Conflict"
  },
  PRECONDITION_FAILED: {
    status: 412,
    message: "Precondition Failed"
  },
  PAYLOAD_TOO_LARGE: {
    status: 413,
    message: "Payload Too Large"
  },
  UNSUPPORTED_MEDIA_TYPE: {
    status: 415,
    message: "Unsupported Media Type"
  },
  UNPROCESSABLE_CONTENT: {
    status: 422,
    message: "Unprocessable Content"
  },
  TOO_MANY_REQUESTS: {
    status: 429,
    message: "Too Many Requests"
  },
  CLIENT_CLOSED_REQUEST: {
    status: 499,
    message: "Client Closed Request"
  },
  INTERNAL_SERVER_ERROR: {
    status: 500,
    message: "Internal Server Error"
  },
  NOT_IMPLEMENTED: {
    status: 501,
    message: "Not Implemented"
  },
  BAD_GATEWAY: {
    status: 502,
    message: "Bad Gateway"
  },
  SERVICE_UNAVAILABLE: {
    status: 503,
    message: "Service Unavailable"
  },
  GATEWAY_TIMEOUT: {
    status: 504,
    message: "Gateway Timeout"
  }
};
function fallbackORPCErrorStatus(code, status) {
  return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;
}
function fallbackORPCErrorMessage(code, message) {
  return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;
}
const GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(`__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`);
void (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());
const globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];
class ORPCError extends Error {
  defined;
  code;
  status;
  data;
  constructor(code, ...rest) {
    const options = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeOptionalOptions)(rest);
    if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {
      throw new Error("[ORPCError] Invalid error status code.");
    }
    const message = fallbackORPCErrorMessage(code, options.message);
    super(message, options);
    this.code = code;
    this.status = fallbackORPCErrorStatus(code, options.status);
    this.defined = options.defined ?? false;
    this.data = options.data;
  }
  toJSON() {
    return {
      defined: this.defined,
      code: this.code,
      status: this.status,
      message: this.message,
      data: this.data
    };
  }
  /**
   * Workaround for Next.js where different contexts use separate
   * dependency graphs, causing multiple ORPCError constructors existing and breaking
   * `instanceof` checks across contexts.
   *
   * This is particularly problematic with "Optimized SSR", where orpc-client
   * executes in one context but is invoked from another. When an error is thrown
   * in the execution context, `instanceof ORPCError` checks fail in the
   * invocation context due to separate class constructors.
   *
   * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.
   */
  static [Symbol.hasInstance](instance) {
    if (globalORPCErrorConstructors.has(this)) {
      const constructor = (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.getConstructor)(instance);
      if (constructor && globalORPCErrorConstructors.has(constructor)) {
        return true;
      }
    }
    return super[Symbol.hasInstance](instance);
  }
}
globalORPCErrorConstructors.add(ORPCError);
function isDefinedError(error) {
  return error instanceof ORPCError && error.defined;
}
function toORPCError(error) {
  return error instanceof ORPCError ? error : new ORPCError("INTERNAL_SERVER_ERROR", {
    message: "Internal server error",
    cause: error
  });
}
function isORPCErrorStatus(status) {
  return status < 200 || status >= 400;
}
function isORPCErrorJson(json) {
  if (!(0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(json)) {
    return false;
  }
  const validKeys = ["defined", "code", "status", "message", "data"];
  if (Object.keys(json).some((k) => !validKeys.includes(k))) {
    return false;
  }
  return "defined" in json && typeof json.defined === "boolean" && "code" in json && typeof json.code === "string" && "status" in json && typeof json.status === "number" && isORPCErrorStatus(json.status) && "message" in json && typeof json.message === "string";
}
function createORPCErrorFromJson(json, options = {}) {
  return new ORPCError(json.code, {
    ...options,
    ...json
  });
}

function mapEventIterator(iterator, maps) {
  const mapError = async (error) => {
    let mappedError = await maps.error(error);
    if (mappedError !== error) {
      const meta = (0,_orpc_standard_server__WEBPACK_IMPORTED_MODULE_1__.getEventMeta)(error);
      if (meta && (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isTypescriptObject)(mappedError)) {
        mappedError = (0,_orpc_standard_server__WEBPACK_IMPORTED_MODULE_1__.withEventMeta)(mappedError, meta);
      }
    }
    return mappedError;
  };
  return new _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.AsyncIteratorClass(async () => {
    const { done, value } = await (async () => {
      try {
        return await iterator.next();
      } catch (error) {
        throw await mapError(error);
      }
    })();
    let mappedValue = await maps.value(value, done);
    if (mappedValue !== value) {
      const meta = (0,_orpc_standard_server__WEBPACK_IMPORTED_MODULE_1__.getEventMeta)(value);
      if (meta && (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isTypescriptObject)(mappedValue)) {
        mappedValue = (0,_orpc_standard_server__WEBPACK_IMPORTED_MODULE_1__.withEventMeta)(mappedValue, meta);
      }
    }
    return { done, value: mappedValue };
  }, async () => {
    try {
      await iterator.return?.();
    } catch (error) {
      throw await mapError(error);
    }
  });
}




}),
"../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs": 
/*!********************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs ***!
  \********************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AbortError: () => (AbortError),
  AsyncIdQueue: () => (AsyncIdQueue),
  AsyncIteratorClass: () => (AsyncIteratorClass),
  EventPublisher: () => (EventPublisher),
  NullProtoObj: () => (NullProtoObj),
  ORPC_NAME: () => (ORPC_NAME),
  ORPC_SHARED_PACKAGE_NAME: () => (ORPC_SHARED_PACKAGE_NAME),
  ORPC_SHARED_PACKAGE_VERSION: () => (ORPC_SHARED_PACKAGE_VERSION),
  SequentialIdGenerator: () => (SequentialIdGenerator),
  asyncIteratorToStream: () => (asyncIteratorToStream),
  asyncIteratorToUnproxiedDataStream: () => (asyncIteratorToUnproxiedDataStream),
  asyncIteratorWithSpan: () => (asyncIteratorWithSpan),
  clone: () => (clone),
  compareSequentialIds: () => (compareSequentialIds),
  defer: () => (defer),
  fallback: () => (fallback),
  findDeepMatches: () => (findDeepMatches),
  get: () => (get),
  getConstructor: () => (getConstructor),
  getGlobalOtelConfig: () => (getGlobalOtelConfig),
  group: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_0__.group),
  guard: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_1__.guard),
  intercept: () => (intercept),
  isAsyncIteratorObject: () => (isAsyncIteratorObject),
  isObject: () => (isObject),
  isPropertyKey: () => (isPropertyKey),
  isTypescriptObject: () => (isTypescriptObject),
  mapEntries: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_2__.mapEntries),
  mapValues: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_2__.mapValues),
  omit: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_2__.omit),
  onError: () => (onError),
  onFinish: () => (onFinish),
  onStart: () => (onStart),
  onSuccess: () => (onSuccess),
  once: () => (once),
  overlayProxy: () => (overlayProxy),
  parseEmptyableJSON: () => (parseEmptyableJSON),
  preventNativeAwait: () => (preventNativeAwait),
  readAsBuffer: () => (readAsBuffer),
  replicateAsyncIterator: () => (replicateAsyncIterator),
  resolveMaybeOptionalOptions: () => (resolveMaybeOptionalOptions),
  retry: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_1__.retry),
  runInSpanContext: () => (runInSpanContext),
  runWithSpan: () => (runWithSpan),
  sequential: () => (sequential),
  setGlobalOtelConfig: () => (setGlobalOtelConfig),
  setSpanAttribute: () => (setSpanAttribute),
  setSpanError: () => (setSpanError),
  sleep: () => (/* reexport safe */ radash__WEBPACK_IMPORTED_MODULE_1__.sleep),
  splitInHalf: () => (splitInHalf),
  startSpan: () => (startSpan),
  streamToAsyncIteratorClass: () => (streamToAsyncIteratorClass),
  stringifyJSON: () => (stringifyJSON),
  toArray: () => (toArray),
  toOtelException: () => (toOtelException),
  toSpanAttributeValue: () => (toSpanAttributeValue),
  tryDecodeURIComponent: () => (tryDecodeURIComponent),
  value: () => (value)
});
/* ESM import */var radash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! radash */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs");
/* ESM import */var radash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! radash */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/async.mjs");
/* ESM import */var radash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! radash */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/object.mjs");


function resolveMaybeOptionalOptions(rest) {
  return rest[0] ?? {};
}

function toArray(value) {
  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];
}
function splitInHalf(arr) {
  const half = Math.ceil(arr.length / 2);
  return [arr.slice(0, half), arr.slice(half)];
}

function readAsBuffer(source) {
  if (typeof source.bytes === "function") {
    return source.bytes();
  }
  return source.arrayBuffer();
}

const ORPC_NAME = "orpc";
const ORPC_SHARED_PACKAGE_NAME = "@orpc/shared";
const ORPC_SHARED_PACKAGE_VERSION = "1.10.4";

class AbortError extends Error {
  constructor(...rest) {
    super(...rest);
    this.name = "AbortError";
  }
}

function once(fn) {
  let cached;
  return () => {
    if (cached) {
      return cached.result;
    }
    const result = fn();
    cached = { result };
    return result;
  };
}
function sequential(fn) {
  let lastOperationPromise = Promise.resolve();
  return (...args) => {
    return lastOperationPromise = lastOperationPromise.catch(() => {
    }).then(() => {
      return fn(...args);
    });
  };
}
function defer(callback) {
  if (typeof setTimeout === "function") {
    setTimeout(callback, 0);
  } else {
    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));
  }
}

const SPAN_ERROR_STATUS = 2;
const GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;
function setGlobalOtelConfig(config) {
  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;
}
function getGlobalOtelConfig() {
  return globalThis[GLOBAL_OTEL_CONFIG_KEY];
}
function startSpan(name, options = {}, context) {
  const tracer = getGlobalOtelConfig()?.tracer;
  return tracer?.startSpan(name, options, context);
}
function setSpanError(span, error, options = {}) {
  if (!span) {
    return;
  }
  const exception = toOtelException(error);
  span.recordException(exception);
  if (!options.signal?.aborted || options.signal.reason !== error) {
    span.setStatus({
      code: SPAN_ERROR_STATUS,
      message: exception.message
    });
  }
}
function setSpanAttribute(span, key, value) {
  if (!span || value === void 0) {
    return;
  }
  span.setAttribute(key, value);
}
function toOtelException(error) {
  if (error instanceof Error) {
    const exception = {
      message: error.message,
      name: error.name,
      stack: error.stack
    };
    if ("code" in error && (typeof error.code === "string" || typeof error.code === "number")) {
      exception.code = error.code;
    }
    return exception;
  }
  return { message: String(error) };
}
function toSpanAttributeValue(data) {
  if (data === void 0) {
    return "undefined";
  }
  try {
    return JSON.stringify(data, (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      if (value instanceof Map || value instanceof Set) {
        return Array.from(value);
      }
      return value;
    });
  } catch {
    return String(data);
  }
}
async function runWithSpan({ name, context, ...options }, fn) {
  const tracer = getGlobalOtelConfig()?.tracer;
  if (!tracer) {
    return fn();
  }
  const callback = async (span) => {
    try {
      return await fn(span);
    } catch (e) {
      setSpanError(span, e, options);
      throw e;
    } finally {
      span.end();
    }
  };
  if (context) {
    return tracer.startActiveSpan(name, options, context, callback);
  } else {
    return tracer.startActiveSpan(name, options, callback);
  }
}
async function runInSpanContext(span, fn) {
  const otelConfig = getGlobalOtelConfig();
  if (!span || !otelConfig) {
    return fn();
  }
  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);
  return otelConfig.context.with(ctx, fn);
}

class AsyncIdQueue {
  openIds = /* @__PURE__ */ new Set();
  queues = /* @__PURE__ */ new Map();
  waiters = /* @__PURE__ */ new Map();
  get length() {
    return this.openIds.size;
  }
  get waiterIds() {
    return Array.from(this.waiters.keys());
  }
  hasBufferedItems(id) {
    return Boolean(this.queues.get(id)?.length);
  }
  open(id) {
    this.openIds.add(id);
  }
  isOpen(id) {
    return this.openIds.has(id);
  }
  push(id, item) {
    this.assertOpen(id);
    const pending = this.waiters.get(id);
    if (pending?.length) {
      pending.shift()[0](item);
      if (pending.length === 0) {
        this.waiters.delete(id);
      }
    } else {
      const items = this.queues.get(id);
      if (items) {
        items.push(item);
      } else {
        this.queues.set(id, [item]);
      }
    }
  }
  async pull(id) {
    this.assertOpen(id);
    const items = this.queues.get(id);
    if (items?.length) {
      const item = items.shift();
      if (items.length === 0) {
        this.queues.delete(id);
      }
      return item;
    }
    return new Promise((resolve, reject) => {
      const waitingPulls = this.waiters.get(id);
      const pending = [resolve, reject];
      if (waitingPulls) {
        waitingPulls.push(pending);
      } else {
        this.waiters.set(id, [pending]);
      }
    });
  }
  close({ id, reason } = {}) {
    if (id === void 0) {
      this.waiters.forEach((pendingPulls, id2) => {
        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);
        pendingPulls.forEach(([, reject]) => reject(error2));
      });
      this.waiters.clear();
      this.openIds.clear();
      this.queues.clear();
      return;
    }
    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);
    this.waiters.get(id)?.forEach(([, reject]) => reject(error));
    this.waiters.delete(id);
    this.openIds.delete(id);
    this.queues.delete(id);
  }
  assertOpen(id) {
    if (!this.isOpen(id)) {
      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);
    }
  }
}

function isAsyncIteratorObject(maybe) {
  if (!maybe || typeof maybe !== "object") {
    return false;
  }
  return "next" in maybe && typeof maybe.next === "function" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === "function";
}
const fallbackAsyncDisposeSymbol = Symbol.for("asyncDispose");
const asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;
class AsyncIteratorClass {
  #isDone = false;
  #isExecuteComplete = false;
  #cleanup;
  #next;
  constructor(next, cleanup) {
    this.#cleanup = cleanup;
    this.#next = sequential(async () => {
      if (this.#isDone) {
        return { done: true, value: void 0 };
      }
      try {
        const result = await next();
        if (result.done) {
          this.#isDone = true;
        }
        return result;
      } catch (err) {
        this.#isDone = true;
        throw err;
      } finally {
        if (this.#isDone && !this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("next");
        }
      }
    });
  }
  next() {
    return this.#next();
  }
  async return(value) {
    this.#isDone = true;
    if (!this.#isExecuteComplete) {
      this.#isExecuteComplete = true;
      await this.#cleanup("return");
    }
    return { done: true, value };
  }
  async throw(err) {
    this.#isDone = true;
    if (!this.#isExecuteComplete) {
      this.#isExecuteComplete = true;
      await this.#cleanup("throw");
    }
    throw err;
  }
  /**
   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
   */
  async [asyncDisposeSymbol]() {
    this.#isDone = true;
    if (!this.#isExecuteComplete) {
      this.#isExecuteComplete = true;
      await this.#cleanup("dispose");
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
function replicateAsyncIterator(source, count) {
  const queue = new AsyncIdQueue();
  const ids = Array.from({ length: count }, (_, i) => i.toString());
  let isSourceFinished = false;
  const start = once(async () => {
    try {
      while (true) {
        const item = await source.next();
        ids.forEach((id) => {
          if (queue.isOpen(id)) {
            queue.push(id, { next: item });
          }
        });
        if (item.done) {
          break;
        }
      }
    } catch (error) {
      ids.forEach((id) => {
        if (queue.isOpen(id)) {
          queue.push(id, { error });
        }
      });
    } finally {
      isSourceFinished = true;
    }
  });
  const replicated = ids.map((id) => {
    queue.open(id);
    return new AsyncIteratorClass(
      async () => {
        start();
        const item = await queue.pull(id);
        if (item.next) {
          return item.next;
        }
        throw item.error;
      },
      async (reason) => {
        queue.close({ id });
        if (reason !== "next" && !queue.length && !isSourceFinished) {
          isSourceFinished = true;
          await source?.return?.();
        }
      }
    );
  });
  return replicated;
}
function asyncIteratorWithSpan({ name, ...options }, iterator) {
  let span;
  return new AsyncIteratorClass(
    async () => {
      span ??= startSpan(name);
      try {
        const result = await runInSpanContext(span, () => iterator.next());
        span?.addEvent(result.done ? "completed" : "yielded");
        return result;
      } catch (err) {
        setSpanError(span, err, options);
        throw err;
      }
    },
    async (reason) => {
      try {
        if (reason !== "next") {
          await runInSpanContext(span, () => iterator.return?.());
        }
      } catch (err) {
        setSpanError(span, err, options);
        throw err;
      } finally {
        span?.end();
      }
    }
  );
}

class EventPublisher {
  #listenersMap = /* @__PURE__ */ new Map();
  #maxBufferedEvents;
  constructor(options = {}) {
    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;
  }
  get size() {
    return this.#listenersMap.size;
  }
  /**
   * Emits an event and delivers the payload to all subscribed listeners.
   */
  publish(event, payload) {
    const listeners = this.#listenersMap.get(event);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(payload);
    }
  }
  subscribe(event, listenerOrOptions) {
    if (typeof listenerOrOptions === "function") {
      let listeners = this.#listenersMap.get(event);
      if (!listeners) {
        this.#listenersMap.set(event, listeners = []);
      }
      listeners.push(listenerOrOptions);
      return once(() => {
        listeners.splice(listeners.indexOf(listenerOrOptions), 1);
        if (listeners.length === 0) {
          this.#listenersMap.delete(event);
        }
      });
    }
    const signal = listenerOrOptions?.signal;
    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;
    signal?.throwIfAborted();
    const bufferedEvents = [];
    const pullResolvers = [];
    const unsubscribe = this.subscribe(event, (payload) => {
      const resolver = pullResolvers.shift();
      if (resolver) {
        resolver[0]({ done: false, value: payload });
      } else {
        bufferedEvents.push(payload);
        if (bufferedEvents.length > maxBufferedEvents) {
          bufferedEvents.shift();
        }
      }
    });
    const abortListener = (event2) => {
      unsubscribe();
      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));
      pullResolvers.length = 0;
      bufferedEvents.length = 0;
    };
    signal?.addEventListener("abort", abortListener, { once: true });
    return new AsyncIteratorClass(async () => {
      if (signal?.aborted) {
        throw signal.reason;
      }
      if (bufferedEvents.length > 0) {
        return { done: false, value: bufferedEvents.shift() };
      }
      return new Promise((resolve, reject) => {
        pullResolvers.push([resolve, reject]);
      });
    }, async () => {
      unsubscribe();
      signal?.removeEventListener("abort", abortListener);
      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));
      pullResolvers.length = 0;
      bufferedEvents.length = 0;
    });
  }
}

class SequentialIdGenerator {
  index = BigInt(1);
  generate() {
    const id = this.index.toString(36);
    this.index++;
    return id;
  }
}
function compareSequentialIds(a, b) {
  if (a.length !== b.length) {
    return a.length - b.length;
  }
  return a < b ? -1 : a > b ? 1 : 0;
}

function onStart(callback) {
  return async (options, ...rest) => {
    await callback(options, ...rest);
    return await options.next();
  };
}
function onSuccess(callback) {
  return async (options, ...rest) => {
    const result = await options.next();
    await callback(result, options, ...rest);
    return result;
  };
}
function onError(callback) {
  return async (options, ...rest) => {
    try {
      return await options.next();
    } catch (error) {
      await callback(error, options, ...rest);
      throw error;
    }
  };
}
function onFinish(callback) {
  let state;
  return async (options, ...rest) => {
    try {
      const result = await options.next();
      state = [null, result, true];
      return result;
    } catch (error) {
      state = [error, void 0, false];
      throw error;
    } finally {
      await callback(state, options, ...rest);
    }
  };
}
function intercept(interceptors, options, main) {
  const next = (options2, index) => {
    const interceptor = interceptors[index];
    if (!interceptor) {
      return main(options2);
    }
    return interceptor({
      ...options2,
      next: (newOptions = options2) => next(newOptions, index + 1)
    });
  };
  return next(options, 0);
}

function parseEmptyableJSON(text) {
  if (!text) {
    return void 0;
  }
  return JSON.parse(text);
}
function stringifyJSON(value) {
  return JSON.stringify(value);
}

function findDeepMatches(check, payload, segments = [], maps = [], values = []) {
  if (check(payload)) {
    maps.push(segments);
    values.push(payload);
  } else if (Array.isArray(payload)) {
    payload.forEach((v, i) => {
      findDeepMatches(check, v, [...segments, i], maps, values);
    });
  } else if (isObject(payload)) {
    for (const key in payload) {
      findDeepMatches(check, payload[key], [...segments, key], maps, values);
    }
  }
  return { maps, values };
}
function getConstructor(value) {
  if (!isTypescriptObject(value)) {
    return null;
  }
  return Object.getPrototypeOf(value)?.constructor;
}
function isObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || !proto || !proto.constructor;
}
function isTypescriptObject(value) {
  return !!value && (typeof value === "object" || typeof value === "function");
}
function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  }
  if (isObject(value)) {
    const result = {};
    for (const key in value) {
      result[key] = clone(value[key]);
    }
    return result;
  }
  return value;
}
function get(object, path) {
  let current = object;
  for (const key of path) {
    if (!isTypescriptObject(current)) {
      return void 0;
    }
    current = current[key];
  }
  return current;
}
function isPropertyKey(value) {
  const type = typeof value;
  return type === "string" || type === "number" || type === "symbol";
}
const NullProtoObj = /* @__PURE__ */ (() => {
  const e = function() {
  };
  e.prototype = /* @__PURE__ */ Object.create(null);
  Object.freeze(e.prototype);
  return e;
})();

function value(value2, ...args) {
  if (typeof value2 === "function") {
    return value2(...args);
  }
  return value2;
}
function fallback(value2, fallback2) {
  return value2 === void 0 ? fallback2 : value2;
}

function preventNativeAwait(target) {
  return new Proxy(target, {
    get(target2, prop, receiver) {
      const value2 = Reflect.get(target2, prop, receiver);
      if (prop !== "then" || typeof value2 !== "function") {
        return value2;
      }
      return new Proxy(value2, {
        apply(targetFn, thisArg, args) {
          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {
            return Reflect.apply(targetFn, thisArg, args);
          }
          let shouldOmit = true;
          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {
            get: (target3, prop2, receiver2) => {
              if (shouldOmit && prop2 === "then") {
                shouldOmit = false;
                return void 0;
              }
              return Reflect.get(target3, prop2, receiver2);
            }
          })));
        }
      });
    }
  });
}
const NATIVE_FUNCTION_REGEX = /^\s*function\s*\(\)\s*\{\s*\[native code\]\s*\}\s*$/;
function isNativeFunction(fn) {
  return typeof fn === "function" && NATIVE_FUNCTION_REGEX.test(fn.toString());
}
function overlayProxy(target, partial) {
  const proxy = new Proxy(typeof target === "function" ? partial : target, {
    get(_, prop) {
      const targetValue = prop in partial ? partial : value(target);
      const v = Reflect.get(targetValue, prop);
      return typeof v === "function" ? v.bind(targetValue) : v;
    },
    has(_, prop) {
      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);
    }
  });
  return proxy;
}

function streamToAsyncIteratorClass(stream) {
  const reader = stream.getReader();
  return new AsyncIteratorClass(
    async () => {
      return reader.read();
    },
    async () => {
      await reader.cancel();
    }
  );
}
function asyncIteratorToStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iterator.return?.();
    }
  });
}
function asyncIteratorToUnproxiedDataStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;
        controller.enqueue(unproxied);
      }
    },
    async cancel() {
      await iterator.return?.();
    }
  });
}

function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch {
    return value;
  }
}




}),
"../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs": 
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.bun/@orpc+standard-server@1.10.4/node_modules/@orpc/standard-server/dist/index.mjs ***!
  \**************************************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ErrorEvent: () => (ErrorEvent),
  EventDecoder: () => (EventDecoder),
  EventDecoderError: () => (EventDecoderError),
  EventDecoderStream: () => (EventDecoderStream),
  EventEncoderError: () => (EventEncoderError),
  HibernationEventIterator: () => (HibernationEventIterator),
  assertEventComment: () => (assertEventComment),
  assertEventId: () => (assertEventId),
  assertEventName: () => (assertEventName),
  assertEventRetry: () => (assertEventRetry),
  decodeEventMessage: () => (decodeEventMessage),
  encodeEventComments: () => (encodeEventComments),
  encodeEventData: () => (encodeEventData),
  encodeEventMessage: () => (encodeEventMessage),
  flattenHeader: () => (flattenHeader),
  generateContentDisposition: () => (generateContentDisposition),
  getEventMeta: () => (getEventMeta),
  getFilenameFromContentDisposition: () => (getFilenameFromContentDisposition),
  isEventIteratorHeaders: () => (isEventIteratorHeaders),
  mergeStandardHeaders: () => (mergeStandardHeaders),
  replicateStandardLazyResponse: () => (replicateStandardLazyResponse),
  withEventMeta: () => (withEventMeta)
});
/* ESM import */var _orpc_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @orpc/shared */ "../../node_modules/.bun/@orpc+shared@1.10.4/node_modules/@orpc/shared/dist/index.mjs");


class EventEncoderError extends TypeError {
}
class EventDecoderError extends TypeError {
}
class ErrorEvent extends Error {
  data;
  constructor(options) {
    super(options?.message ?? "An error event was received", options);
    this.data = options?.data;
  }
}

function decodeEventMessage(encoded) {
  const lines = encoded.replace(/\n+$/, "").split(/\n/);
  const message = {
    data: void 0,
    event: void 0,
    id: void 0,
    retry: void 0,
    comments: []
  };
  for (const line of lines) {
    const index = line.indexOf(":");
    const key = index === -1 ? line : line.slice(0, index);
    const value = index === -1 ? "" : line.slice(index + 1).replace(/^\s/, "");
    if (index === 0) {
      message.comments.push(value);
    } else if (key === "data") {
      message.data ??= "";
      message.data += `${value}
`;
    } else if (key === "event") {
      message.event = value;
    } else if (key === "id") {
      message.id = value;
    } else if (key === "retry") {
      const maybeInteger = Number.parseInt(value);
      if (Number.isInteger(maybeInteger) && maybeInteger >= 0 && maybeInteger.toString() === value) {
        message.retry = maybeInteger;
      }
    }
  }
  message.data = message.data?.replace(/\n$/, "");
  return message;
}
class EventDecoder {
  constructor(options = {}) {
    this.options = options;
  }
  incomplete = "";
  feed(chunk) {
    this.incomplete += chunk;
    const lastCompleteIndex = this.incomplete.lastIndexOf("\n\n");
    if (lastCompleteIndex === -1) {
      return;
    }
    const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\n\n/);
    this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);
    for (const encoded of completes) {
      const message = decodeEventMessage(`${encoded}

`);
      if (this.options.onEvent) {
        this.options.onEvent(message);
      }
    }
    this.incomplete = "";
  }
  end() {
    if (this.incomplete) {
      throw new EventDecoderError("Event Iterator ended before complete");
    }
  }
}
class EventDecoderStream extends TransformStream {
  constructor() {
    let decoder;
    super({
      start(controller) {
        decoder = new EventDecoder({
          onEvent: (event) => {
            controller.enqueue(event);
          }
        });
      },
      transform(chunk) {
        decoder.feed(chunk);
      },
      flush() {
        decoder.end();
      }
    });
  }
}

function assertEventId(id) {
  if (id.includes("\n")) {
    throw new EventEncoderError("Event's id must not contain a newline character");
  }
}
function assertEventName(event) {
  if (event.includes("\n")) {
    throw new EventEncoderError("Event's event must not contain a newline character");
  }
}
function assertEventRetry(retry) {
  if (!Number.isInteger(retry) || retry < 0) {
    throw new EventEncoderError("Event's retry must be a integer and >= 0");
  }
}
function assertEventComment(comment) {
  if (comment.includes("\n")) {
    throw new EventEncoderError("Event's comment must not contain a newline character");
  }
}
function encodeEventData(data) {
  const lines = data?.split(/\n/) ?? [];
  let output = "";
  for (const line of lines) {
    output += `data: ${line}
`;
  }
  return output;
}
function encodeEventComments(comments) {
  let output = "";
  for (const comment of comments ?? []) {
    assertEventComment(comment);
    output += `: ${comment}
`;
  }
  return output;
}
function encodeEventMessage(message) {
  let output = "";
  output += encodeEventComments(message.comments);
  if (message.event !== void 0) {
    assertEventName(message.event);
    output += `event: ${message.event}
`;
  }
  if (message.retry !== void 0) {
    assertEventRetry(message.retry);
    output += `retry: ${message.retry}
`;
  }
  if (message.id !== void 0) {
    assertEventId(message.id);
    output += `id: ${message.id}
`;
  }
  output += encodeEventData(message.data);
  output += "\n";
  return output;
}

const EVENT_SOURCE_META_SYMBOL = Symbol("ORPC_EVENT_SOURCE_META");
function withEventMeta(container, meta) {
  if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {
    return container;
  }
  if (meta.id !== void 0) {
    assertEventId(meta.id);
  }
  if (meta.retry !== void 0) {
    assertEventRetry(meta.retry);
  }
  if (meta.comments !== void 0) {
    for (const comment of meta.comments) {
      assertEventComment(comment);
    }
  }
  return new Proxy(container, {
    get(target, prop, receiver) {
      if (prop === EVENT_SOURCE_META_SYMBOL) {
        return meta;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function getEventMeta(container) {
  return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isTypescriptObject)(container) ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL) : void 0;
}

class HibernationEventIterator extends _orpc_shared__WEBPACK_IMPORTED_MODULE_0__.AsyncIteratorClass {
  /**
   * this property is not transferred to the client, so it should be optional for type safety
   */
  hibernationCallback;
  constructor(hibernationCallback) {
    super(async () => {
      throw new Error("Cannot iterate over hibernating iterator directly");
    }, async (reason) => {
      if (reason !== "next") {
        throw new Error("Cannot cleanup hibernating iterator directly");
      }
    });
    this.hibernationCallback = hibernationCallback;
  }
}

function generateContentDisposition(filename) {
  const escapedFileName = filename.replace(/"/g, '\\"');
  const encodedFilenameStar = encodeURIComponent(filename).replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));
  return `inline; filename="${escapedFileName}"; filename*=utf-8''${encodedFilenameStar}`;
}
function getFilenameFromContentDisposition(contentDisposition) {
  const encodedFilenameStarMatch = contentDisposition.match(/filename\*=(UTF-8'')?([^;]*)/i);
  if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === "string") {
    return (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.tryDecodeURIComponent)(encodedFilenameStarMatch[2]);
  }
  const encodedFilenameMatch = contentDisposition.match(/filename="((?:\\"|[^"])*)"/i);
  if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === "string") {
    return encodedFilenameMatch[1].replace(/\\"/g, '"');
  }
}
function mergeStandardHeaders(a, b) {
  const merged = { ...a };
  for (const key in b) {
    if (Array.isArray(b[key])) {
      merged[key] = [...(0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(merged[key]), ...b[key]];
    } else if (b[key] !== void 0) {
      if (Array.isArray(merged[key])) {
        merged[key] = [...merged[key], b[key]];
      } else if (merged[key] !== void 0) {
        merged[key] = [merged[key], b[key]];
      } else {
        merged[key] = b[key];
      }
    }
  }
  return merged;
}
function flattenHeader(header) {
  if (typeof header === "string" || header === void 0) {
    return header;
  }
  if (header.length === 0) {
    return void 0;
  }
  return header.join(", ");
}
function replicateStandardLazyResponse(response, count) {
  const replicated = [];
  let bodyPromise;
  let replicatedAsyncIteratorObjects;
  for (let i = 0; i < count; i++) {
    replicated.push({
      ...response,
      body: (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
        const body = await (bodyPromise ??= response.body());
        if (!(0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.isAsyncIteratorObject)(body)) {
          return body;
        }
        replicatedAsyncIteratorObjects ??= (0,_orpc_shared__WEBPACK_IMPORTED_MODULE_0__.replicateAsyncIterator)(body, count);
        return replicatedAsyncIteratorObjects.shift();
      })
    });
  }
  return replicated;
}
function isEventIteratorHeaders(headers) {
  return Boolean(flattenHeader(headers["content-type"])?.startsWith("text/event-stream") && flattenHeader(headers["content-disposition"]) === void 0);
}




}),
"../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs": 
/*!************************************************************************************!*\
  !*** ../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs ***!
  \************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  alphabetical: () => (alphabetical),
  boil: () => (boil),
  cluster: () => (cluster),
  counting: () => (counting),
  diff: () => (diff),
  first: () => (first),
  flat: () => (flat),
  fork: () => (fork),
  group: () => (group),
  intersects: () => (intersects),
  iterate: () => (iterate),
  last: () => (last),
  list: () => (list),
  max: () => (max),
  merge: () => (merge),
  min: () => (min),
  objectify: () => (objectify),
  range: () => (range),
  replace: () => (replace),
  replaceOrAppend: () => (replaceOrAppend),
  select: () => (select),
  shift: () => (shift),
  sift: () => (sift),
  sort: () => (sort),
  sum: () => (sum),
  toggle: () => (toggle),
  unique: () => (unique),
  zip: () => (zip),
  zipToObject: () => (zipToObject)
});
/* ESM import */var _typed_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typed.mjs */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs");


const group = (array, getGroupId) => {
  return array.reduce((acc, item) => {
    const groupId = getGroupId(item);
    if (!acc[groupId])
      acc[groupId] = [];
    acc[groupId].push(item);
    return acc;
  }, {});
};
function zip(...arrays) {
  if (!arrays || !arrays.length)
    return [];
  return new Array(Math.max(...arrays.map(({ length }) => length))).fill([]).map((_, idx) => arrays.map((array) => array[idx]));
}
function zipToObject(keys, values) {
  if (!keys || !keys.length) {
    return {};
  }
  const getValue = (0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(values) ? values : (0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isArray)(values) ? (_k, i) => values[i] : (_k, _i) => values;
  return keys.reduce((acc, key, idx) => {
    acc[key] = getValue(key, idx);
    return acc;
  }, {});
}
const boil = (array, compareFunc) => {
  if (!array || (array.length ?? 0) === 0)
    return null;
  return array.reduce(compareFunc);
};
function sum(array, fn) {
  return (array || []).reduce((acc, item) => acc + (fn ? fn(item) : item), 0);
}
const first = (array, defaultValue = void 0) => {
  return array?.length > 0 ? array[0] : defaultValue;
};
const last = (array, defaultValue = void 0) => {
  return array?.length > 0 ? array[array.length - 1] : defaultValue;
};
const sort = (array, getter, desc = false) => {
  if (!array)
    return [];
  const asc = (a, b) => getter(a) - getter(b);
  const dsc = (a, b) => getter(b) - getter(a);
  return array.slice().sort(desc === true ? dsc : asc);
};
const alphabetical = (array, getter, dir = "asc") => {
  if (!array)
    return [];
  const asc = (a, b) => `${getter(a)}`.localeCompare(getter(b));
  const dsc = (a, b) => `${getter(b)}`.localeCompare(getter(a));
  return array.slice().sort(dir === "desc" ? dsc : asc);
};
const counting = (list2, identity) => {
  if (!list2)
    return {};
  return list2.reduce((acc, item) => {
    const id = identity(item);
    acc[id] = (acc[id] ?? 0) + 1;
    return acc;
  }, {});
};
const replace = (list2, newItem, match) => {
  if (!list2)
    return [];
  if (newItem === void 0)
    return [...list2];
  for (let idx = 0; idx < list2.length; idx++) {
    const item = list2[idx];
    if (match(item, idx)) {
      return [
        ...list2.slice(0, idx),
        newItem,
        ...list2.slice(idx + 1, list2.length)
      ];
    }
  }
  return [...list2];
};
const objectify = (array, getKey, getValue = (item) => item) => {
  return array.reduce((acc, item) => {
    acc[getKey(item)] = getValue(item);
    return acc;
  }, {});
};
const select = (array, mapper, condition) => {
  if (!array)
    return [];
  return array.reduce((acc, item, index) => {
    if (!condition(item, index))
      return acc;
    acc.push(mapper(item, index));
    return acc;
  }, []);
};
function max(array, getter) {
  const get = getter ?? ((v) => v);
  return boil(array, (a, b) => get(a) > get(b) ? a : b);
}
function min(array, getter) {
  const get = getter ?? ((v) => v);
  return boil(array, (a, b) => get(a) < get(b) ? a : b);
}
const cluster = (list2, size = 2) => {
  const clusterCount = Math.ceil(list2.length / size);
  return new Array(clusterCount).fill(null).map((_c, i) => {
    return list2.slice(i * size, i * size + size);
  });
};
const unique = (array, toKey) => {
  const valueMap = array.reduce((acc, item) => {
    const key = toKey ? toKey(item) : item;
    if (acc[key])
      return acc;
    acc[key] = item;
    return acc;
  }, {});
  return Object.values(valueMap);
};
function* range(startOrLength, end, valueOrMapper = (i) => i, step = 1) {
  const mapper = (0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(valueOrMapper) ? valueOrMapper : () => valueOrMapper;
  const start = end ? startOrLength : 0;
  const final = end ?? startOrLength;
  for (let i = start; i <= final; i += step) {
    yield mapper(i);
    if (i + step > final)
      break;
  }
}
const list = (startOrLength, end, valueOrMapper, step) => {
  return Array.from(range(startOrLength, end, valueOrMapper, step));
};
const flat = (lists) => {
  return lists.reduce((acc, list2) => {
    acc.push(...list2);
    return acc;
  }, []);
};
const intersects = (listA, listB, identity) => {
  if (!listA || !listB)
    return false;
  const ident = identity ?? ((x) => x);
  const dictB = listB.reduce((acc, item) => {
    acc[ident(item)] = true;
    return acc;
  }, {});
  return listA.some((value) => dictB[ident(value)]);
};
const fork = (list2, condition) => {
  if (!list2)
    return [[], []];
  return list2.reduce(
    (acc, item) => {
      const [a, b] = acc;
      if (condition(item)) {
        return [[...a, item], b];
      } else {
        return [a, [...b, item]];
      }
    },
    [[], []]
  );
};
const merge = (root, others, matcher) => {
  if (!others && !root)
    return [];
  if (!others)
    return root;
  if (!root)
    return [];
  if (!matcher)
    return root;
  return root.reduce((acc, r) => {
    const matched = others.find((o) => matcher(r) === matcher(o));
    if (matched)
      acc.push(matched);
    else
      acc.push(r);
    return acc;
  }, []);
};
const replaceOrAppend = (list2, newItem, match) => {
  if (!list2 && !newItem)
    return [];
  if (!newItem)
    return [...list2];
  if (!list2)
    return [newItem];
  for (let idx = 0; idx < list2.length; idx++) {
    const item = list2[idx];
    if (match(item, idx)) {
      return [
        ...list2.slice(0, idx),
        newItem,
        ...list2.slice(idx + 1, list2.length)
      ];
    }
  }
  return [...list2, newItem];
};
const toggle = (list2, item, toKey, options) => {
  if (!list2 && !item)
    return [];
  if (!list2)
    return [item];
  if (!item)
    return [...list2];
  const matcher = toKey ? (x, idx) => toKey(x, idx) === toKey(item, idx) : (x) => x === item;
  const existing = list2.find(matcher);
  if (existing)
    return list2.filter((x, idx) => !matcher(x, idx));
  const strategy = options?.strategy ?? "append";
  if (strategy === "append")
    return [...list2, item];
  return [item, ...list2];
};
const sift = (list2) => {
  return list2?.filter((x) => !!x) ?? [];
};
const iterate = (count, func, initValue) => {
  let value = initValue;
  for (let i = 1; i <= count; i++) {
    value = func(value, i);
  }
  return value;
};
const diff = (root, other, identity = (t) => t) => {
  if (!root?.length && !other?.length)
    return [];
  if (root?.length === void 0)
    return [...other];
  if (!other?.length)
    return [...root];
  const bKeys = other.reduce((acc, item) => {
    acc[identity(item)] = true;
    return acc;
  }, {});
  return root.filter((a) => !bKeys[identity(a)]);
};
function shift(arr, n) {
  if (arr.length === 0)
    return arr;
  const shiftNumber = n % arr.length;
  if (shiftNumber === 0)
    return arr;
  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)];
}


//# sourceMappingURL=array.mjs.map


}),
"../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/async.mjs": 
/*!************************************************************************************!*\
  !*** ../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/async.mjs ***!
  \************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AggregateError: () => (AggregateError),
  all: () => (all),
  defer: () => (defer),
  guard: () => (guard),
  map: () => (map),
  parallel: () => (parallel),
  reduce: () => (reduce),
  retry: () => (retry),
  sleep: () => (sleep),
  tryit: () => (tryit)
});
/* ESM import */var _array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.mjs */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs");
/* ESM import */var _typed_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typed.mjs */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs");



const reduce = async (array, asyncReducer, initValue) => {
  const initProvided = initValue !== void 0;
  if (!initProvided && array?.length < 1) {
    throw new Error("Cannot reduce empty array with no init value");
  }
  const iter = initProvided ? array : array.slice(1);
  let value = initProvided ? initValue : array[0];
  for (const [i, item] of iter.entries()) {
    value = await asyncReducer(value, item, i);
  }
  return value;
};
const map = async (array, asyncMapFunc) => {
  if (!array)
    return [];
  let result = [];
  let index = 0;
  for (const value of array) {
    const newValue = await asyncMapFunc(value, index++);
    result.push(newValue);
  }
  return result;
};
const defer = async (func) => {
  const callbacks = [];
  const register = (fn, options) => callbacks.push({
    fn,
    rethrow: options?.rethrow ?? false
  });
  const [err, response] = await tryit(func)(register);
  for (const { fn, rethrow } of callbacks) {
    const [rethrown] = await tryit(fn)(err);
    if (rethrown && rethrow)
      throw rethrown;
  }
  if (err)
    throw err;
  return response;
};
class AggregateError extends Error {
  constructor(errors = []) {
    super();
    const name = errors.find((e) => e.name)?.name ?? "";
    this.name = `AggregateError(${name}...)`;
    this.message = `AggregateError with ${errors.length} errors`;
    this.stack = errors.find((e) => e.stack)?.stack ?? this.stack;
    this.errors = errors;
  }
}
const parallel = async (limit, array, func) => {
  const work = array.map((item, index) => ({
    index,
    item
  }));
  const processor = async (res) => {
    const results2 = [];
    while (true) {
      const next = work.pop();
      if (!next)
        return res(results2);
      const [error, result] = await tryit(func)(next.item);
      results2.push({
        error,
        result,
        index: next.index
      });
    }
  };
  const queues = (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.list)(1, limit).map(() => new Promise(processor));
  const itemResults = await Promise.all(queues);
  const [errors, results] = (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.fork)(
    (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.sort)(itemResults.flat(), (r) => r.index),
    (x) => !!x.error
  );
  if (errors.length > 0) {
    throw new AggregateError(errors.map((error) => error.error));
  }
  return results.map((r) => r.result);
};
async function all(promises) {
  const entries = (0,_typed_mjs__WEBPACK_IMPORTED_MODULE_1__.isArray)(promises) ? promises.map((p) => [null, p]) : Object.entries(promises);
  const results = await Promise.all(
    entries.map(
      ([key, value]) => value.then((result) => ({ result, exc: null, key })).catch((exc) => ({ result: null, exc, key }))
    )
  );
  const exceptions = results.filter((r) => r.exc);
  if (exceptions.length > 0) {
    throw new AggregateError(exceptions.map((e) => e.exc));
  }
  if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_1__.isArray)(promises)) {
    return results.map((r) => r.result);
  }
  return results.reduce(
    (acc, item) => ({
      ...acc,
      [item.key]: item.result
    }),
    {}
  );
}
const retry = async (options, func) => {
  const times = options?.times ?? 3;
  const delay = options?.delay;
  const backoff = options?.backoff ?? null;
  for (const i of (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.range)(1, times)) {
    const [err, result] = await tryit(func)((err2) => {
      throw { _exited: err2 };
    });
    if (!err)
      return result;
    if (err._exited)
      throw err._exited;
    if (i === times)
      throw err;
    if (delay)
      await sleep(delay);
    if (backoff)
      await sleep(backoff(i));
  }
  return void 0;
};
const sleep = (milliseconds) => {
  return new Promise((res) => setTimeout(res, milliseconds));
};
const tryit = (func) => {
  return (...args) => {
    try {
      const result = func(...args);
      if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_1__.isPromise)(result)) {
        return result.then((value) => [void 0, value]).catch((err) => [err, void 0]);
      }
      return [void 0, result];
    } catch (err) {
      return [err, void 0];
    }
  };
};
const guard = (func, shouldGuard) => {
  const _guard = (err) => {
    if (shouldGuard && !shouldGuard(err))
      throw err;
    return void 0;
  };
  const isPromise2 = (result) => result instanceof Promise;
  try {
    const result = func();
    return isPromise2(result) ? result.catch(_guard) : result;
  } catch (err) {
    return _guard(err);
  }
};


//# sourceMappingURL=async.mjs.map


}),
"../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/object.mjs": 
/*!*************************************************************************************!*\
  !*** ../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/object.mjs ***!
  \*************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  assign: () => (assign),
  clone: () => (clone),
  construct: () => (construct),
  crush: () => (crush),
  get: () => (get),
  invert: () => (invert),
  keys: () => (keys),
  listify: () => (listify),
  lowerize: () => (lowerize),
  mapEntries: () => (mapEntries),
  mapKeys: () => (mapKeys),
  mapValues: () => (mapValues),
  omit: () => (omit),
  pick: () => (pick),
  set: () => (set),
  shake: () => (shake),
  upperize: () => (upperize)
});
/* ESM import */var _array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.mjs */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/array.mjs");
/* ESM import */var _typed_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typed.mjs */ "../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs");



const shake = (obj, filter = (x) => x === void 0) => {
  if (!obj)
    return {};
  const keys2 = Object.keys(obj);
  return keys2.reduce((acc, key) => {
    if (filter(obj[key])) {
      return acc;
    } else {
      acc[key] = obj[key];
      return acc;
    }
  }, {});
};
const mapKeys = (obj, mapFunc) => {
  const keys2 = Object.keys(obj);
  return keys2.reduce((acc, key) => {
    acc[mapFunc(key, obj[key])] = obj[key];
    return acc;
  }, {});
};
const mapValues = (obj, mapFunc) => {
  const keys2 = Object.keys(obj);
  return keys2.reduce((acc, key) => {
    acc[key] = mapFunc(obj[key], key);
    return acc;
  }, {});
};
const mapEntries = (obj, toEntry) => {
  if (!obj)
    return {};
  return Object.entries(obj).reduce((acc, [key, value]) => {
    const [newKey, newValue] = toEntry(key, value);
    acc[newKey] = newValue;
    return acc;
  }, {});
};
const invert = (obj) => {
  if (!obj)
    return {};
  const keys2 = Object.keys(obj);
  return keys2.reduce((acc, key) => {
    acc[obj[key]] = key;
    return acc;
  }, {});
};
const lowerize = (obj) => mapKeys(obj, (k) => k.toLowerCase());
const upperize = (obj) => mapKeys(obj, (k) => k.toUpperCase());
const clone = (obj) => {
  if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isPrimitive)(obj)) {
    return obj;
  }
  if (typeof obj === "function") {
    return obj.bind({});
  }
  const newObj = new obj.constructor();
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    newObj[prop] = obj[prop];
  });
  return newObj;
};
const listify = (obj, toItem) => {
  if (!obj)
    return [];
  const entries = Object.entries(obj);
  if (entries.length === 0)
    return [];
  return entries.reduce((acc, entry) => {
    acc.push(toItem(entry[0], entry[1]));
    return acc;
  }, []);
};
const pick = (obj, keys2) => {
  if (!obj)
    return {};
  return keys2.reduce((acc, key) => {
    if (Object.prototype.hasOwnProperty.call(obj, key))
      acc[key] = obj[key];
    return acc;
  }, {});
};
const omit = (obj, keys2) => {
  if (!obj)
    return {};
  if (!keys2 || keys2.length === 0)
    return obj;
  return keys2.reduce(
    (acc, key) => {
      delete acc[key];
      return acc;
    },
    { ...obj }
  );
};
const get = (value, path, defaultValue) => {
  const segments = path.split(/[\.\[\]]/g);
  let current = value;
  for (const key of segments) {
    if (current === null)
      return defaultValue;
    if (current === void 0)
      return defaultValue;
    const dequoted = key.replace(/['"]/g, "");
    if (dequoted.trim() === "")
      continue;
    current = current[dequoted];
  }
  if (current === void 0)
    return defaultValue;
  return current;
};
const set = (initial, path, value) => {
  if (!initial)
    return {};
  if (!path || value === void 0)
    return initial;
  const segments = path.split(/[\.\[\]]/g).filter((x) => !!x.trim());
  const _set = (node) => {
    if (segments.length > 1) {
      const key = segments.shift();
      const nextIsNum = /^\d+$/.test(segments[0]);
      node[key] = node[key] === void 0 ? nextIsNum ? [] : {} : node[key];
      _set(node[key]);
    } else {
      node[segments[0]] = value;
    }
  };
  const cloned = clone(initial);
  _set(cloned);
  return cloned;
};
const assign = (initial, override) => {
  if (!initial || !override)
    return initial ?? override ?? {};
  return Object.entries({ ...initial, ...override }).reduce(
    (acc, [key, value]) => {
      return {
        ...acc,
        [key]: (() => {
          if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(initial[key]))
            return assign(initial[key], value);
          return value;
        })()
      };
    },
    {}
  );
};
const keys = (value) => {
  if (!value)
    return [];
  const getKeys = (nested, paths) => {
    if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(nested)) {
      return Object.entries(nested).flatMap(
        ([k, v]) => getKeys(v, [...paths, k])
      );
    }
    if ((0,_typed_mjs__WEBPACK_IMPORTED_MODULE_0__.isArray)(nested)) {
      return nested.flatMap((item, i) => getKeys(item, [...paths, `${i}`]));
    }
    return [paths.join(".")];
  };
  return getKeys(value, []);
};
const crush = (value) => {
  if (!value)
    return {};
  return (0,_array_mjs__WEBPACK_IMPORTED_MODULE_1__.objectify)(
    keys(value),
    (k) => k,
    (k) => get(value, k)
  );
};
const construct = (obj) => {
  if (!obj)
    return {};
  return Object.keys(obj).reduce((acc, path) => {
    return set(acc, path, obj[path]);
  }, {});
};


//# sourceMappingURL=object.mjs.map


}),
"../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs": 
/*!************************************************************************************!*\
  !*** ../../node_modules/.bun/radash@12.1.1/node_modules/radash/dist/esm/typed.mjs ***!
  \************************************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isArray: () => (isArray),
  isDate: () => (isDate),
  isEmpty: () => (isEmpty),
  isEqual: () => (isEqual),
  isFloat: () => (isFloat),
  isFunction: () => (isFunction),
  isInt: () => (isInt),
  isNumber: () => (isNumber),
  isObject: () => (isObject),
  isPrimitive: () => (isPrimitive),
  isPromise: () => (isPromise),
  isString: () => (isString),
  isSymbol: () => (isSymbol)
});
const isSymbol = (value) => {
  return !!value && value.constructor === Symbol;
};
const isArray = Array.isArray;
const isObject = (value) => {
  return !!value && value.constructor === Object;
};
const isPrimitive = (value) => {
  return value === void 0 || value === null || typeof value !== "object" && typeof value !== "function";
};
const isFunction = (value) => {
  return !!(value && value.constructor && value.call && value.apply);
};
const isString = (value) => {
  return typeof value === "string" || value instanceof String;
};
const isInt = (value) => {
  return isNumber(value) && value % 1 === 0;
};
const isFloat = (value) => {
  return isNumber(value) && value % 1 !== 0;
};
const isNumber = (value) => {
  try {
    return Number(value) === value;
  } catch {
    return false;
  }
};
const isDate = (value) => {
  return Object.prototype.toString.call(value) === "[object Date]";
};
const isPromise = (value) => {
  if (!value)
    return false;
  if (!value.then)
    return false;
  if (!isFunction(value.then))
    return false;
  return true;
};
const isEmpty = (value) => {
  if (value === true || value === false)
    return true;
  if (value === null || value === void 0)
    return true;
  if (isNumber(value))
    return value === 0;
  if (isDate(value))
    return isNaN(value.getTime());
  if (isFunction(value))
    return false;
  if (isSymbol(value))
    return false;
  const length = value.length;
  if (isNumber(length))
    return length === 0;
  const size = value.size;
  if (isNumber(size))
    return size === 0;
  const keys = Object.keys(value).length;
  return keys === 0;
};
const isEqual = (x, y) => {
  if (Object.is(x, y))
    return true;
  if (x instanceof Date && y instanceof Date) {
    return x.getTime() === y.getTime();
  }
  if (x instanceof RegExp && y instanceof RegExp) {
    return x.toString() === y.toString();
  }
  if (typeof x !== "object" || x === null || typeof y !== "object" || y === null) {
    return false;
  }
  const keysX = Reflect.ownKeys(x);
  const keysY = Reflect.ownKeys(y);
  if (keysX.length !== keysY.length)
    return false;
  for (let i = 0; i < keysX.length; i++) {
    if (!Reflect.has(y, keysX[i]))
      return false;
    if (!isEqual(x[keysX[i]], y[keysX[i]]))
      return false;
  }
  return true;
};


//# sourceMappingURL=typed.mjs.map


}),

};
;
//# sourceMappingURL=vendors-node_modules_bun_orpc_client_1_10_4_node_modules_orpc_client_dist_shared_client_DmkMd-ec2cea.js.map